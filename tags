!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Alloc	rainbow/fiber.cpp	/^    static void* Alloc(size_t size) {$/;"	f	class:rainbow::MallocStackAllocator	access:public	signature:(size_t size)
Backtrace	rainbow/util.cpp	/^void Backtrace(std::vector<std::string>& bt, int size, int skip) {$/;"	f	namespace:rainbow	signature:(std::vector<std::string>& bt, int size, int skip)
Backtrace	rainbow/util.h	/^void Backtrace(std::vector<std::string>& bt, int size = 64, int skip = 1);$/;"	p	namespace:rainbow	signature:(std::vector<std::string>& bt, int size = 64, int skip = 1)
BacktraceToString	rainbow/util.cpp	/^std::string BacktraceToString(const std::string& prefix, int size, int skip) {$/;"	f	namespace:rainbow	signature:(const std::string& prefix, int size, int skip)
BacktraceToString	rainbow/util.h	/^std::string BacktraceToString(const std::string& prefix = "", int size = 64, int skip = 2);$/;"	p	namespace:rainbow	signature:(const std::string& prefix = Ó, int size = 64, int skip = 2)
CASLock	rainbow/thread.h	/^    CASLock() {$/;"	f	class:rainbow::CASLock	access:public	signature:()
CASLock	rainbow/thread.h	/^class CASLock {$/;"	c	namespace:rainbow
CC	Makefile	/^CC		:= g++ -std=c++11 -g3 -Wall -pthread$/;"	m
CallerMainFunc	rainbow/fiber.cpp	/^void Fiber::CallerMainFunc() {$/;"	f	class:rainbow::Fiber	signature:()
CallerMainFunc	rainbow/fiber.h	/^    static void CallerMainFunc();$/;"	p	class:rainbow::Fiber	access:public	signature:()
Comparator	rainbow/timer.h	/^    struct Comparator {$/;"	s	class:rainbow::Timer	access:private
Config	rainbow/config.h	/^class Config {$/;"	c	namespace:rainbow
ConfigVar	rainbow/config.h	/^    ConfigVar(const std::string& name$/;"	f	class:rainbow::ConfigVar	access:public	signature:(const std::string& name , const T& default_value , const std::string& description = Ó)
ConfigVar	rainbow/config.h	/^class ConfigVar : public ConfigVarBase {$/;"	c	namespace:rainbow	inherits:ConfigVarBase
ConfigVarBase	rainbow/config.h	/^    ConfigVarBase(const std::string& name, const std::string& description = "") $/;"	f	class:rainbow::ConfigVarBase	access:public	signature:(const std::string& name, const std::string& description = Ó)
ConfigVarBase	rainbow/config.h	/^class ConfigVarBase {$/;"	c	namespace:rainbow
ConfigVarMap	rainbow/config.h	/^    typedef std::unordered_map<std::string, ConfigVarBase::ptr> ConfigVarMap;$/;"	t	class:rainbow::Config	access:public
DEBUG	rainbow/log.h	/^        DEBUG = 1,$/;"	e	enum:rainbow::LogLevel::Level
DEFINES	Makefile	/^DEFINES := -lyaml-cpp$/;"	m
DateTimeFormatItem	rainbow/log.cpp	/^    DateTimeFormatItem(const std::string& format = "%Y-%m-%d %H:%M:%s")$/;"	f	class:rainbow::DateTimeFormatItem	access:public	signature:(const std::string& format = Ó)
DateTimeFormatItem	rainbow/log.cpp	/^class DateTimeFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
Dealloc	rainbow/fiber.cpp	/^    static void Dealloc(void* vp, size_t size) {$/;"	f	class:rainbow::MallocStackAllocator	access:public	signature:(void* vp, size_t size)
ERROR	rainbow/log.h	/^        ERROR = 4,$/;"	e	enum:rainbow::LogLevel::Level
EXCEPT	rainbow/fiber.h	/^        EXCEPT$/;"	e	enum:rainbow::Fiber::State
EXEC	rainbow/fiber.h	/^        EXEC,$/;"	e	enum:rainbow::Fiber::State
ElapseFormatItem	rainbow/log.cpp	/^    ElapseFormatItem(const std::string str = "") {}$/;"	f	class:rainbow::ElapseFormatItem	access:public	signature:(const std::string str = Ó)
ElapseFormatItem	rainbow/log.cpp	/^class ElapseFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
Event	rainbow/iomanager.h	/^    enum Event {$/;"	g	class:rainbow::IOManager	access:public
EventContext	rainbow/iomanager.h	/^        struct EventContext {$/;"	s	struct:rainbow::IOManager::FdContext	access:public
FATAL	rainbow/log.h	/^        FATAL = 5$/;"	e	enum:rainbow::LogLevel::Level
FdContext	rainbow/iomanager.h	/^    struct FdContext {$/;"	s	class:rainbow::IOManager	access:private
Fiber	rainbow/fiber.cpp	/^Fiber::Fiber() {$/;"	f	class:rainbow::Fiber	signature:()
Fiber	rainbow/fiber.cpp	/^Fiber::Fiber(std::function<void()> cb, size_t stacksize, bool use_caller) $/;"	f	class:rainbow::Fiber	signature:(std::function<void()> cb, size_t stacksize, bool use_caller)
Fiber	rainbow/fiber.h	/^    Fiber();$/;"	p	class:rainbow::Fiber	access:private	signature:()
Fiber	rainbow/fiber.h	/^    Fiber(std::function<void()> cb, size_t stacksize = 0, bool use_caller = false);$/;"	p	class:rainbow::Fiber	access:public	signature:(std::function<void()> cb, size_t stacksize = 0, bool use_caller = false)
Fiber	rainbow/fiber.h	/^class Fiber : public std::enable_shared_from_this<Fiber> {$/;"	c	namespace:rainbow	inherits:std::enable_shared_from_this
FiberAndThread	rainbow/scheduler.h	/^        FiberAndThread()$/;"	f	struct:rainbow::Scheduler::FiberAndThread	access:public	signature:()
FiberAndThread	rainbow/scheduler.h	/^        FiberAndThread(Fiber::ptr f, int thr)$/;"	f	struct:rainbow::Scheduler::FiberAndThread	access:public	signature:(Fiber::ptr f, int thr)
FiberAndThread	rainbow/scheduler.h	/^        FiberAndThread(Fiber::ptr* f, int thr) $/;"	f	struct:rainbow::Scheduler::FiberAndThread	access:public	signature:(Fiber::ptr* f, int thr)
FiberAndThread	rainbow/scheduler.h	/^        FiberAndThread(std::function<void()> f, int thr) $/;"	f	struct:rainbow::Scheduler::FiberAndThread	access:public	signature:(std::function<void()> f, int thr)
FiberAndThread	rainbow/scheduler.h	/^        FiberAndThread(std::function<void()>* f, int thr) $/;"	f	struct:rainbow::Scheduler::FiberAndThread	access:public	signature:(std::function<void()>* f, int thr)
FiberAndThread	rainbow/scheduler.h	/^    struct FiberAndThread {$/;"	s	class:rainbow::Scheduler	access:private
FiberIdFormatItem	rainbow/log.cpp	/^    FiberIdFormatItem(const std::string str = "") {}$/;"	f	class:rainbow::FiberIdFormatItem	access:public	signature:(const std::string str = Ó)
FiberIdFormatItem	rainbow/log.cpp	/^class FiberIdFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
FileLogAppender	rainbow/log.cpp	/^FileLogAppender::FileLogAppender(const std::string& name) : m_filename(name) {$/;"	f	class:rainbow::FileLogAppender	signature:(const std::string& name)
FileLogAppender	rainbow/log.h	/^    FileLogAppender(const std::string& filename);$/;"	p	class:rainbow::FileLogAppender	access:public	signature:(const std::string& filename)
FileLogAppender	rainbow/log.h	/^class FileLogAppender : public LogAppender {$/;"	c	namespace:rainbow	inherits:LogAppender
FileNameFormatItem	rainbow/log.cpp	/^    FileNameFormatItem(const std::string str = "") {}$/;"	f	class:rainbow::FileNameFormatItem	access:public	signature:(const std::string str = Ó)
FileNameFormatItem	rainbow/log.cpp	/^class FileNameFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
FormatItem	rainbow/log.h	/^        FormatItem(const std::string& fmt = ""){};$/;"	f	class:rainbow::LogFormatter::FormatItem	access:public	signature:(const std::string& fmt = Ó)
FormatItem	rainbow/log.h	/^    class FormatItem {$/;"	c	class:rainbow::LogFormatter	access:public
FromString	rainbow/log.cpp	/^LogLevel::Level LogLevel::FromString(const std::string& str) {$/;"	f	class:rainbow::LogLevel	signature:(const std::string& str)
FromString	rainbow/log.h	/^    static LogLevel::Level FromString(const std::string& str);$/;"	p	class:rainbow::LogLevel	access:public	signature:(const std::string& str)
GetCurrentMS	rainbow/util.cpp	/^uint64_t GetCurrentMS() {$/;"	f	namespace:rainbow	signature:()
GetCurrentMS	rainbow/util.h	/^uint64_t GetCurrentMS();$/;"	p	namespace:rainbow	signature:()
GetCurrentUS	rainbow/util.cpp	/^uint64_t GetCurrentUS() {$/;"	f	namespace:rainbow	signature:()
GetCurrentUS	rainbow/util.h	/^uint64_t GetCurrentUS();$/;"	p	namespace:rainbow	signature:()
GetDatas	rainbow/config.h	/^    static ConfigVarMap& GetDatas() {$/;"	f	class:rainbow::Config	access:private	signature:()
GetFiberId	rainbow/fiber.cpp	/^uint64_t Fiber::GetFiberId() {$/;"	f	class:rainbow::Fiber	signature:()
GetFiberId	rainbow/fiber.h	/^    static uint64_t GetFiberId();$/;"	p	class:rainbow::Fiber	access:public	signature:()
GetFiberId	rainbow/util.cpp	/^uint32_t GetFiberId() {$/;"	f	namespace:rainbow	signature:()
GetFiberId	rainbow/util.h	/^uint32_t GetFiberId();$/;"	p	namespace:rainbow	signature:()
GetId	rainbow/fiber.h	/^    uint64_t GetId() const { return m_id; }$/;"	f	class:rainbow::Fiber	access:public	signature:() const
GetInstance	rainbow/singleton.h	/^    static T* GetInstance() {$/;"	f	class:rainbow::Singleton	access:public	signature:()
GetInstance	rainbow/singleton.h	/^    static std::shared_ptr<T> GetInstance() {$/;"	f	class:rainbow::Singletonptr	access:public	signature:()
GetMainFiber	rainbow/scheduler.cpp	/^Fiber* Scheduler::GetMainFiber() {$/;"	f	class:rainbow::Scheduler	signature:()
GetMainFiber	rainbow/scheduler.h	/^    static Fiber* GetMainFiber();$/;"	p	class:rainbow::Scheduler	access:public	signature:()
GetMutex	rainbow/config.h	/^    static RWMutexType& GetMutex() {$/;"	f	class:rainbow::Config	access:private	signature:()
GetName	rainbow/thread.cpp	/^const std::string& Thread::GetName() {$/;"	f	class:rainbow::Thread	signature:()
GetName	rainbow/thread.h	/^    static const std::string& GetName();$/;"	p	class:rainbow::Thread	access:public	signature:()
GetThis	rainbow/fiber.cpp	/^Fiber::ptr Fiber::GetThis() {$/;"	f	class:rainbow::Fiber	signature:()
GetThis	rainbow/fiber.h	/^    static Fiber::ptr GetThis();$/;"	p	class:rainbow::Fiber	access:public	signature:()
GetThis	rainbow/iomanager.cpp	/^IOManager* IOManager::GetThis() {$/;"	f	class:rainbow::IOManager	signature:()
GetThis	rainbow/iomanager.h	/^    static IOManager* GetThis();$/;"	p	class:rainbow::IOManager	access:public	signature:()
GetThis	rainbow/scheduler.cpp	/^Scheduler* Scheduler::GetThis() {$/;"	f	class:rainbow::Scheduler	signature:()
GetThis	rainbow/scheduler.h	/^    static Scheduler* GetThis();$/;"	p	class:rainbow::Scheduler	access:public	signature:()
GetThis	rainbow/thread.cpp	/^Thread* Thread::GetThis() {$/;"	f	class:rainbow::Thread	signature:()
GetThis	rainbow/thread.h	/^    static Thread* GetThis();$/;"	p	class:rainbow::Thread	access:public	signature:()
GetThreadId	rainbow/util.cpp	/^pid_t GetThreadId() {$/;"	f	namespace:rainbow	signature:()
GetThreadId	rainbow/util.h	/^pid_t GetThreadId();$/;"	p	namespace:rainbow	signature:()
HOLD	rainbow/fiber.h	/^        HOLD,$/;"	e	enum:rainbow::Fiber::State
INCDIR	Makefile	/^INCDIR := $(patsubst %, -I %, $(incdirs))$/;"	m
INFO	rainbow/log.h	/^        INFO = 2,$/;"	e	enum:rainbow::LogLevel::Level
INIT	rainbow/fiber.h	/^        INIT,$/;"	e	enum:rainbow::Fiber::State
IOManager	rainbow/iomanager.cpp	/^IOManager::IOManager(size_t threads, bool use_caller, const std::string& name)$/;"	f	class:rainbow::IOManager	signature:(size_t threads, bool use_caller, const std::string& name)
IOManager	rainbow/iomanager.h	/^    IOManager(size_t threads = 1, bool use_caller = true, const std::string& name = "");$/;"	p	class:rainbow::IOManager	access:public	signature:(size_t threads = 1, bool use_caller = true, const std::string& name = Ó)
IOManager	rainbow/iomanager.h	/^class IOManager : public Scheduler, public TimerManager{$/;"	c	namespace:rainbow	inherits:Scheduler,TimerManager
Level	rainbow/log.h	/^    enum Level {$/;"	g	class:rainbow::LogLevel	access:public
LevelFormatItem	rainbow/log.cpp	/^    LevelFormatItem(const std::string str = "") {}$/;"	f	class:rainbow::LevelFormatItem	access:public	signature:(const std::string str = Ó)
LevelFormatItem	rainbow/log.cpp	/^class LevelFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
LexicalCast	rainbow/config.h	/^class LexicalCast {$/;"	c	namespace:rainbow
LexicalCast	rainbow/config.h	/^class LexicalCast<std::list<T>, std::string> {$/;"	c	namespace:rainbow
LexicalCast	rainbow/config.h	/^class LexicalCast<std::map<std::string, T>, std::string> {$/;"	c	namespace:rainbow
LexicalCast	rainbow/config.h	/^class LexicalCast<std::set<T>, std::string> {$/;"	c	namespace:rainbow
LexicalCast	rainbow/config.h	/^class LexicalCast<std::string, std::list<T> > {$/;"	c	namespace:rainbow
LexicalCast	rainbow/config.h	/^class LexicalCast<std::string, std::map<std::string, T> > {$/;"	c	namespace:rainbow
LexicalCast	rainbow/config.h	/^class LexicalCast<std::string, std::set<T> > {$/;"	c	namespace:rainbow
LexicalCast	rainbow/config.h	/^class LexicalCast<std::string, std::unordered_map<std::string, T> > {$/;"	c	namespace:rainbow
LexicalCast	rainbow/config.h	/^class LexicalCast<std::string, std::unordered_set<T> > {$/;"	c	namespace:rainbow
LexicalCast	rainbow/config.h	/^class LexicalCast<std::string, std::vector<T> > {$/;"	c	namespace:rainbow
LexicalCast	rainbow/config.h	/^class LexicalCast<std::unordered_map<std::string, T>, std::string> {$/;"	c	namespace:rainbow
LexicalCast	rainbow/config.h	/^class LexicalCast<std::unordered_set<T>, std::string> {$/;"	c	namespace:rainbow
LexicalCast	rainbow/config.h	/^class LexicalCast<std::vector<T>, std::string> {$/;"	c	namespace:rainbow
LexicalCast	rainbow/log.cpp	/^class LexicalCast<std::set<LogDefine>, std::string> {$/;"	c	namespace:rainbow	file:
LexicalCast	rainbow/log.cpp	/^class LexicalCast<std::string, std::set<LogDefine> > {$/;"	c	namespace:rainbow	file:
LexicalCast	tests/test_config.cpp	/^class LexicalCast<Person, std::string> {$/;"	c	namespace:rainbow	file:
LexicalCast	tests/test_config.cpp	/^class LexicalCast<std::string, Person> {$/;"	c	namespace:rainbow	file:
LineFormatItem	rainbow/log.cpp	/^    LineFormatItem(const std::string str = "") {}$/;"	f	class:rainbow::LineFormatItem	access:public	signature:(const std::string str = Ó)
LineFormatItem	rainbow/log.cpp	/^class LineFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
ListAllMember	rainbow/config.cpp	/^static void ListAllMember(const std::string& prefix, $/;"	f	namespace:rainbow	signature:(const std::string& prefix, const YAML::Node& node, std::list<std::pair<std::string, const YAML::Node> >& output)
LoadFromYaml	rainbow/config.cpp	/^void Config::LoadFromYaml(const YAML::Node& root) {$/;"	f	class:rainbow::Config	signature:(const YAML::Node& root)
LoadFromYaml	rainbow/config.h	/^    static void LoadFromYaml(const YAML::Node& root);$/;"	p	class:rainbow::Config	access:public	signature:(const YAML::Node& root)
Lock	rainbow/thread.h	/^    typedef ScopedLockImpl<CASLock> Lock;$/;"	t	class:rainbow::CASLock	access:public
Lock	rainbow/thread.h	/^    typedef ScopedLockImpl<Mutex> Lock;$/;"	t	class:rainbow::Mutex	access:public
Lock	rainbow/thread.h	/^    typedef ScopedLockImpl<NullMutex> Lock;$/;"	t	class:rainbow::NullMutex	access:public
Lock	rainbow/thread.h	/^    typedef ScopedLockImpl<Spinlock> Lock;$/;"	t	class:rainbow::Spinlock	access:public
LogAppender	rainbow/log.cpp	/^LogAppender::LogAppender() {$/;"	f	class:rainbow::LogAppender	signature:()
LogAppender	rainbow/log.h	/^    LogAppender();$/;"	p	class:rainbow::LogAppender	access:public	signature:()
LogAppender	rainbow/log.h	/^class LogAppender {$/;"	c	namespace:rainbow
LogAppenderDefine	rainbow/log.cpp	/^struct LogAppenderDefine {$/;"	s	namespace:rainbow	file:
LogDefine	rainbow/log.cpp	/^struct LogDefine {$/;"	s	namespace:rainbow	file:
LogEvent	rainbow/log.cpp	/^LogEvent::LogEvent(const std::shared_ptr<Logger> logger, LogLevel::Level level, const char* file, $/;"	f	class:rainbow::LogEvent	signature:(const std::shared_ptr<Logger> logger, LogLevel::Level level, const char* file, int32_t line, uint32_t elapse, uint32_t thread_id, uint32_t fiber_id, uint64_t time, const std::string& threadName)
LogEvent	rainbow/log.h	/^    LogEvent(std::shared_ptr<Logger> logger, LogLevel::Level level, const char* file, $/;"	p	class:rainbow::LogEvent	access:public	signature:(std::shared_ptr<Logger> logger, LogLevel::Level level, const char* file, int32_t m_line, uint32_t elapse, uint32_t thread_id, uint32_t fiber_id, uint64_t time, const std::string& thread_name)
LogEvent	rainbow/log.h	/^class LogEvent {$/;"	c	namespace:rainbow
LogEventWrap	rainbow/log.cpp	/^LogEventWrap::LogEventWrap(LogEvent::ptr e) : m_event(e) {$/;"	f	class:rainbow::LogEventWrap	signature:(LogEvent::ptr e)
LogEventWrap	rainbow/log.h	/^    LogEventWrap(LogEvent::ptr e);$/;"	p	class:rainbow::LogEventWrap	access:public	signature:(LogEvent::ptr e)
LogEventWrap	rainbow/log.h	/^class LogEventWrap {$/;"	c	namespace:rainbow
LogFormatter	rainbow/log.cpp	/^LogFormatter::LogFormatter(const std::string& pattern) : m_pattern(pattern) {$/;"	f	class:rainbow::LogFormatter	signature:(const std::string& pattern)
LogFormatter	rainbow/log.h	/^    LogFormatter(const std::string& pattern);$/;"	p	class:rainbow::LogFormatter	access:public	signature:(const std::string& pattern)
LogFormatter	rainbow/log.h	/^class LogFormatter {$/;"	c	namespace:rainbow
LogIniter	rainbow/log.cpp	/^    LogIniter() {$/;"	f	struct:rainbow::LogIniter	access:public	signature:()
LogIniter	rainbow/log.cpp	/^struct LogIniter {$/;"	s	namespace:rainbow	file:
LogLevel	rainbow/log.h	/^class LogLevel {$/;"	c	namespace:rainbow
Logger	rainbow/log.cpp	/^Logger::Logger(const std::string& name)$/;"	f	class:rainbow::Logger	signature:(const std::string& name)
Logger	rainbow/log.h	/^    Logger(const std::string& name = "root");$/;"	p	class:rainbow::Logger	access:public	signature:(const std::string& name = Ó)
Logger	rainbow/log.h	/^class Logger : public std::enable_shared_from_this<Logger> {$/;"	c	namespace:rainbow	inherits:std::enable_shared_from_this
LoggerManager	rainbow/log.cpp	/^LoggerManager::LoggerManager() {$/;"	f	class:rainbow::LoggerManager	signature:()
LoggerManager	rainbow/log.h	/^    LoggerManager();$/;"	p	class:rainbow::LoggerManager	access:public	signature:()
LoggerManager	rainbow/log.h	/^class LoggerManager {$/;"	c	namespace:rainbow
LoggerMgr	rainbow/log.h	/^typedef rainbow::Singleton<LoggerManager> LoggerMgr;$/;"	t	namespace:rainbow
LookUpBase	rainbow/config.cpp	/^ConfigVarBase::ptr Config::LookUpBase(const std::string& name) {$/;"	f	class:rainbow::Config	signature:(const std::string& name)
LookUpBase	rainbow/config.h	/^    static ConfigVarBase::ptr LookUpBase(const std::string& name);$/;"	p	class:rainbow::Config	access:public	signature:(const std::string& name)
Lookup	rainbow/config.h	/^    static typename ConfigVar<T>::ptr Lookup(const std::string& name) {$/;"	f	class:rainbow::Config	access:public	signature:(const std::string& name)
Lookup	rainbow/config.h	/^    static typename ConfigVar<T>::ptr Lookup(const std::string& name,$/;"	f	class:rainbow::Config	access:public	signature:(const std::string& name, const T& default_value, const std::string& description = Ó)
MainFunc	rainbow/fiber.cpp	/^void Fiber::MainFunc() {$/;"	f	class:rainbow::Fiber	signature:()
MainFunc	rainbow/fiber.h	/^    static void MainFunc();$/;"	p	class:rainbow::Fiber	access:public	signature:()
MallocStackAllocator	rainbow/fiber.cpp	/^class MallocStackAllocator {$/;"	c	namespace:rainbow	file:
MessageFormatItem	rainbow/log.cpp	/^    MessageFormatItem(const std::string& str = "") {}$/;"	f	class:rainbow::MessageFormatItem	access:public	signature:(const std::string& str = Ó)
MessageFormatItem	rainbow/log.cpp	/^class MessageFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
Mutex	rainbow/thread.h	/^    Mutex() {$/;"	f	class:rainbow::Mutex	access:public	signature:()
Mutex	rainbow/thread.h	/^class Mutex {$/;"	c	namespace:rainbow
MutexType	rainbow/iomanager.h	/^        typedef Mutex MutexType;$/;"	t	struct:rainbow::IOManager::FdContext	access:public
MutexType	rainbow/log.h	/^    typedef Spinlock MutexType;$/;"	t	class:rainbow::LogAppender	access:public
MutexType	rainbow/log.h	/^    typedef Spinlock MutexType;$/;"	t	class:rainbow::Logger	access:public
MutexType	rainbow/log.h	/^    typedef Spinlock MutexType;$/;"	t	class:rainbow::LoggerManager	access:public
MutexType	rainbow/scheduler.h	/^    typedef Mutex MutexType;$/;"	t	class:rainbow::Scheduler	access:public
NONE	rainbow/iomanager.h	/^        NONE    = 0x0,$/;"	e	enum:rainbow::IOManager::Event
NameFormatItem	rainbow/log.cpp	/^    NameFormatItem(const std::string& str = "") {}$/;"	f	class:rainbow::NameFormatItem	access:public	signature:(const std::string& str = Ó)
NameFormatItem	rainbow/log.cpp	/^class NameFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
NewLineFormatItem	rainbow/log.cpp	/^    NewLineFormatItem(const std::string str = "") {}$/;"	f	class:rainbow::NewLineFormatItem	access:public	signature:(const std::string str = Ó)
NewLineFormatItem	rainbow/log.cpp	/^class NewLineFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
NullMutex	rainbow/thread.h	/^    NullMutex() {}$/;"	f	class:rainbow::NullMutex	access:public	signature:()
NullMutex	rainbow/thread.h	/^class NullMutex {$/;"	c	namespace:rainbow
NullRWMutex	rainbow/thread.h	/^    NullRWMutex() {}$/;"	f	class:rainbow::NullRWMutex	access:public	signature:()
NullRWMutex	rainbow/thread.h	/^class NullRWMutex {$/;"	c	namespace:rainbow
OnTimer	rainbow/timer.cpp	/^static void OnTimer(std::weak_ptr<void> weak_cond, std::function<void()> cb) {$/;"	f	namespace:rainbow	signature:(std::weak_ptr<void> weak_cond, std::function<void()> cb)
Person	tests/test_config.cpp	/^    Person() {}$/;"	f	class:Person	access:public	signature:()
Person	tests/test_config.cpp	/^class Person {$/;"	c	file:
Person::Person	tests/test_config.cpp	/^    Person() {}$/;"	f	class:Person	access:public	signature:()
Person::m_age	tests/test_config.cpp	/^    int m_age = 0;$/;"	m	class:Person	file:	access:public
Person::m_name	tests/test_config.cpp	/^    std::string m_name;$/;"	m	class:Person	file:	access:public
Person::m_sex	tests/test_config.cpp	/^    bool m_sex = 0;$/;"	m	class:Person	file:	access:public
Person::operator ==	tests/test_config.cpp	/^    bool operator==(const Person& oth) const {$/;"	f	class:Person	access:public	signature:(const Person& oth) const
Person::toString	tests/test_config.cpp	/^    std::string toString() const {$/;"	f	class:Person	access:public	signature:() const
RAINBOW_ASSERT	rainbow/macro.h	9;"	d
RAINBOW_ASSERT2	rainbow/macro.h	17;"	d
RAINBOW_LOG_DEBUG	rainbow/log.h	25;"	d
RAINBOW_LOG_ERROR	rainbow/log.h	28;"	d
RAINBOW_LOG_FATAL	rainbow/log.h	29;"	d
RAINBOW_LOG_FMT_DEBUG	rainbow/log.h	37;"	d
RAINBOW_LOG_FMT_ERROR	rainbow/log.h	40;"	d
RAINBOW_LOG_FMT_FATAL	rainbow/log.h	41;"	d
RAINBOW_LOG_FMT_INFO	rainbow/log.h	38;"	d
RAINBOW_LOG_FMT_LEVEL	rainbow/log.h	31;"	d
RAINBOW_LOG_FMT_WARN	rainbow/log.h	39;"	d
RAINBOW_LOG_INFO	rainbow/log.h	26;"	d
RAINBOW_LOG_LEVEL	rainbow/log.h	21;"	d
RAINBOW_LOG_NAME	rainbow/log.h	45;"	d
RAINBOW_LOG_ROOT	rainbow/log.h	44;"	d
RAINBOW_LOG_WARN	rainbow/log.h	27;"	d
READ	rainbow/iomanager.h	/^        READ    = 0x1,  \/\/ EPOLLIN$/;"	e	enum:rainbow::IOManager::Event
READY	rainbow/fiber.h	/^        READY,$/;"	e	enum:rainbow::Fiber::State
RWMutex	rainbow/thread.h	/^    RWMutex() {$/;"	f	class:rainbow::RWMutex	access:public	signature:()
RWMutex	rainbow/thread.h	/^class RWMutex {$/;"	c	namespace:rainbow
RWMutexType	rainbow/config.h	/^    typedef RWMutex RWMutexType;$/;"	t	class:rainbow::Config	access:public
RWMutexType	rainbow/config.h	/^    typedef RWMutex RWMutexType;$/;"	t	class:rainbow::ConfigVar	access:public
RWMutexType	rainbow/iomanager.h	/^    typedef RWMutex RWMutexType;$/;"	t	class:rainbow::IOManager	access:public
RWMutexType	rainbow/timer.h	/^    typedef RWMutex RWMutexType;$/;"	t	class:rainbow::TimerManager	access:public
ReadLock	rainbow/thread.h	/^    typedef ReadScopedLockImpl<NullMutex> ReadLock;$/;"	t	class:rainbow::NullRWMutex	access:public
ReadLock	rainbow/thread.h	/^    typedef ReadScopedLockImpl<RWMutex> ReadLock;$/;"	t	class:rainbow::RWMutex	access:public
ReadScopedLockImpl	rainbow/thread.h	/^    ReadScopedLockImpl(T& mutex)$/;"	f	struct:rainbow::ReadScopedLockImpl	access:public	signature:(T& mutex)
ReadScopedLockImpl	rainbow/thread.h	/^struct ReadScopedLockImpl {$/;"	s	namespace:rainbow
Scheduler	rainbow/scheduler.cpp	/^Scheduler::Scheduler(size_t threads, bool use_caller, const std::string& name)$/;"	f	class:rainbow::Scheduler	signature:(size_t threads, bool use_caller, const std::string& name)
Scheduler	rainbow/scheduler.h	/^    Scheduler(size_t threads = 1, bool use_caller = true, const std::string& name = "");$/;"	p	class:rainbow::Scheduler	access:public	signature:(size_t threads = 1, bool use_caller = true, const std::string& name = Ó)
Scheduler	rainbow/scheduler.h	/^class Scheduler {$/;"	c	namespace:rainbow
ScopedLockImpl	rainbow/thread.h	/^    ScopedLockImpl(T& mutex)$/;"	f	struct:rainbow::ScopedLockImpl	access:public	signature:(T& mutex)
ScopedLockImpl	rainbow/thread.h	/^struct ScopedLockImpl {$/;"	s	namespace:rainbow
Semaphore	rainbow/thread.cpp	/^Semaphore::Semaphore(uint32_t count) {$/;"	f	class:rainbow::Semaphore	signature:(uint32_t count)
Semaphore	rainbow/thread.h	/^    Semaphore(const Semaphore&&) = delete;$/;"	p	class:rainbow::Semaphore	access:private	signature:(const Semaphore&&)
Semaphore	rainbow/thread.h	/^    Semaphore(const Semaphore&) = delete;$/;"	p	class:rainbow::Semaphore	access:private	signature:(const Semaphore&)
Semaphore	rainbow/thread.h	/^    Semaphore(uint32_t count = 0);$/;"	p	class:rainbow::Semaphore	access:public	signature:(uint32_t count = 0)
Semaphore	rainbow/thread.h	/^class Semaphore {$/;"	c	namespace:rainbow
SetName	rainbow/thread.cpp	/^void Thread::SetName(const std::string& name) {$/;"	f	class:rainbow::Thread	signature:(const std::string& name)
SetName	rainbow/thread.h	/^    static void SetName(const std::string& name);$/;"	p	class:rainbow::Thread	access:public	signature:(const std::string& name)
SetThis	rainbow/fiber.cpp	/^void Fiber::SetThis(Fiber* f) {$/;"	f	class:rainbow::Fiber	signature:(Fiber* f)
SetThis	rainbow/fiber.h	/^    static void SetThis(Fiber* f);$/;"	p	class:rainbow::Fiber	access:public	signature:(Fiber* f)
Singleton	rainbow/singleton.h	/^class Singleton {$/;"	c	namespace:rainbow
Singletonptr	rainbow/singleton.h	/^class Singletonptr {$/;"	c	namespace:rainbow
Spinlock	rainbow/thread.h	/^    Spinlock() {$/;"	f	class:rainbow::Spinlock	access:public	signature:()
Spinlock	rainbow/thread.h	/^class Spinlock {$/;"	c	namespace:rainbow
State	rainbow/fiber.h	/^    enum State {$/;"	g	class:rainbow::Fiber	access:public
StdoutLogAppender	rainbow/log.h	/^class StdoutLogAppender : public LogAppender {$/;"	c	namespace:rainbow	inherits:LogAppender
StringFormatItem	rainbow/log.cpp	/^    StringFormatItem(const std::string& str) : m_string(str) {}$/;"	f	class:rainbow::StringFormatItem	access:public	signature:(const std::string& str)
StringFormatItem	rainbow/log.cpp	/^class StringFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
TERM	rainbow/fiber.h	/^        TERM,$/;"	e	enum:rainbow::Fiber::State
TabFormatItem	rainbow/log.cpp	/^     TabFormatItem(const std::string& str = "") {}$/;"	f	class:rainbow::TabFormatItem	access:public	signature:(const std::string& str = Ó)
TabFormatItem	rainbow/log.cpp	/^class TabFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
Thread	rainbow/thread.cpp	/^Thread::Thread(std::function<void()> cb, const std::string& name) $/;"	f	class:rainbow::Thread	signature:(std::function<void()> cb, const std::string& name)
Thread	rainbow/thread.h	/^    Thread(const Thread&&) = delete;$/;"	p	class:rainbow::Thread	access:private	signature:(const Thread&&)
Thread	rainbow/thread.h	/^    Thread(const Thread&) = delete;$/;"	p	class:rainbow::Thread	access:private	signature:(const Thread&)
Thread	rainbow/thread.h	/^    Thread(std::function<void()> cb, const std::string& name);$/;"	p	class:rainbow::Thread	access:public	signature:(std::function<void()> cb, const std::string& name)
Thread	rainbow/thread.h	/^class Thread {$/;"	c	namespace:rainbow
ThreadIdFormatItem	rainbow/log.cpp	/^    ThreadIdFormatItem(const std::string str = "") {}$/;"	f	class:rainbow::ThreadIdFormatItem	access:public	signature:(const std::string str = Ó)
ThreadIdFormatItem	rainbow/log.cpp	/^class ThreadIdFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
ThreadNameFormatItem	rainbow/log.cpp	/^    ThreadNameFormatItem(const std::string str = "") {}$/;"	f	class:rainbow::ThreadNameFormatItem	access:public	signature:(const std::string str = Ó)
ThreadNameFormatItem	rainbow/log.cpp	/^class ThreadNameFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
Timer	rainbow/timer.cpp	/^Timer::Timer(uint64_t ms, std::function<void()> cb,$/;"	f	class:rainbow::Timer	signature:(uint64_t ms, std::function<void()> cb, bool recurring, TimerManager* manager)
Timer	rainbow/timer.cpp	/^Timer::Timer(uint64_t next) $/;"	f	class:rainbow::Timer	signature:(uint64_t next)
Timer	rainbow/timer.h	/^    Timer(uint64_t ms, std::function<void()> cb,$/;"	p	class:rainbow::Timer	access:private	signature:(uint64_t ms, std::function<void()> cb, bool recurring, TimerManager* manager)
Timer	rainbow/timer.h	/^    Timer(uint64_t next);$/;"	p	class:rainbow::Timer	access:private	signature:(uint64_t next)
Timer	rainbow/timer.h	/^class Timer : public std::enable_shared_from_this<Timer> {$/;"	c	namespace:rainbow	inherits:std::enable_shared_from_this
TimerManager	rainbow/timer.cpp	/^TimerManager::TimerManager() {$/;"	f	class:rainbow::TimerManager	signature:()
TimerManager	rainbow/timer.h	/^    TimerManager();$/;"	p	class:rainbow::TimerManager	access:public	signature:()
TimerManager	rainbow/timer.h	/^class TimerManager {$/;"	c	namespace:rainbow
ToString	rainbow/log.cpp	/^const char* LogLevel::ToString(LogLevel::Level level) {$/;"	f	class:rainbow::LogLevel	signature:(LogLevel::Level level)
ToString	rainbow/log.h	/^    static const char* ToString(LogLevel::Level level);$/;"	p	class:rainbow::LogLevel	access:public	signature:(LogLevel::Level level)
TotalFibers	rainbow/fiber.cpp	/^uint64_t Fiber::TotalFibers() {$/;"	f	class:rainbow::Fiber	signature:()
TotalFibers	rainbow/fiber.h	/^    static uint64_t TotalFibers();$/;"	p	class:rainbow::Fiber	access:public	signature:()
UNKNOW	rainbow/log.h	/^        UNKNOW = 0,$/;"	e	enum:rainbow::LogLevel::Level
Visit	rainbow/config.cpp	/^void Config::Visit(std::function<void(ConfigVarBase::ptr)> cb) {$/;"	f	class:rainbow::Config	signature:(std::function<void(ConfigVarBase::ptr)> cb)
Visit	rainbow/config.h	/^    static void Visit(std::function<void(ConfigVarBase::ptr cb)>);$/;"	p	class:rainbow::Config	access:public	signature:(std::function<void(ConfigVarBase::ptr cb)>)
WARN	rainbow/log.h	/^        WARN = 3,$/;"	e	enum:rainbow::LogLevel::Level
WRITE	rainbow/iomanager.h	/^        WRITE   = 0x4,  \/\/ EPOLLOUT$/;"	e	enum:rainbow::IOManager::Event
WriteLock	rainbow/thread.h	/^    typedef WriteScopedLockImpl<NullMutex> WriteLock;$/;"	t	class:rainbow::NullRWMutex	access:public
WriteLock	rainbow/thread.h	/^    typedef WriteScopedLockImpl<RWMutex> WriteLock;$/;"	t	class:rainbow::RWMutex	access:public
WriteScopedLockImpl	rainbow/thread.h	/^    WriteScopedLockImpl(T& mutex)$/;"	f	struct:rainbow::WriteScopedLockImpl	access:public	signature:(T& mutex)
WriteScopedLockImpl	rainbow/thread.h	/^struct WriteScopedLockImpl {$/;"	s	namespace:rainbow
XX	rainbow/log.cpp	15;"	d	file:
XX	rainbow/log.cpp	25;"	d	file:
XX	rainbow/log.cpp	33;"	d	file:
XX	rainbow/log.cpp	486;"	d	file:
XX	rainbow/log.cpp	501;"	d	file:
XX	rainbow/log.cpp	50;"	d	file:
XX_PM	tests/test_config.cpp	180;"	d	file:
YieldToHold	rainbow/fiber.cpp	/^void Fiber::YieldToHold() {$/;"	f	class:rainbow::Fiber	signature:()
YieldToHold	rainbow/fiber.h	/^    static void YieldToHold();$/;"	p	class:rainbow::Fiber	access:public	signature:()
YieldToReady	rainbow/fiber.cpp	/^void Fiber::YieldToReady() {$/;"	f	class:rainbow::Fiber	signature:()
YieldToReady	rainbow/fiber.h	/^    static void YieldToReady();$/;"	p	class:rainbow::Fiber	access:public	signature:()
__FIBER_H__	rainbow/fiber.h	2;"	d
__RAINBOW_CONFIG_H__	rainbow/config.h	2;"	d
__RAINBOW_IOMANAGER_H__	rainbow/iomanager.h	2;"	d
__RAINBOW_LOG_H	rainbow/log.h	2;"	d
__RAINBOW_MACRO_H__	rainbow/macro.h	2;"	d
__RAINBOW_RAINBOW_H__	rainbow/rainbow.h	2;"	d
__RAINBOW_SINGLETON_H_	rainbow/singleton.h	2;"	d
__RAINBOW_THREAD_H__	rainbow/thread.h	2;"	d
__RAINBOW_TIMER_H__	rainbow/timer.h	2;"	d
__RAINBOW_UTIL_H_	rainbow/util.h	2;"	d
__SCHEDULER_H__	rainbow/scheduler.h	2;"	d
__log_init	rainbow/log.cpp	/^static LogIniter __log_init;$/;"	m	namespace:rainbow	file:
addAppender	rainbow/log.cpp	/^void Logger::addAppender(LogAppender::ptr appender) {$/;"	f	class:rainbow::Logger	signature:(LogAppender::ptr appender)
addAppender	rainbow/log.h	/^    void addAppender(LogAppender::ptr appender);$/;"	p	class:rainbow::Logger	access:public	signature:(LogAppender::ptr appender)
addConditionTimer	rainbow/timer.cpp	/^Timer::ptr TimerManager::addConditionTimer(uint64_t ms, std::function<void()> cb$/;"	f	class:rainbow::TimerManager	signature:(uint64_t ms, std::function<void()> cb ,std::weak_ptr<void> weak_cond ,bool recurring)
addConditionTimer	rainbow/timer.h	/^    Timer::ptr addConditionTimer(uint64_t ms, std::function<void()> cb$/;"	p	class:rainbow::TimerManager	access:public	signature:(uint64_t ms, std::function<void()> cb ,std::weak_ptr<void> weak_cond ,bool recurring = false)
addEvent	rainbow/iomanager.cpp	/^int IOManager::addEvent(int fd, Event event, std::function<void()> cb) {$/;"	f	class:rainbow::IOManager	signature:(int fd, Event event, std::function<void()> cb)
addEvent	rainbow/iomanager.h	/^    int addEvent(int fd, Event event, std::function<void()> cb = nullptr);$/;"	p	class:rainbow::IOManager	access:public	signature:(int fd, Event event, std::function<void()> cb = nullptr)
addListener	rainbow/config.h	/^    uint64_t addListener(on_change_cb cb) {$/;"	f	class:rainbow::ConfigVar	access:public	signature:(on_change_cb cb)
addTimer	rainbow/timer.cpp	/^Timer::ptr TimerManager::addTimer(uint64_t ms, std::function<void()> cb$/;"	f	class:rainbow::TimerManager	signature:(uint64_t ms, std::function<void()> cb ,bool recurring)
addTimer	rainbow/timer.cpp	/^void TimerManager::addTimer(Timer::ptr val, RWMutexType::WriteLock& lock) {$/;"	f	class:rainbow::TimerManager	signature:(Timer::ptr val, RWMutexType::WriteLock& lock)
addTimer	rainbow/timer.h	/^    Timer::ptr addTimer(uint64_t ms, std::function<void()> cb$/;"	p	class:rainbow::TimerManager	access:public	signature:(uint64_t ms, std::function<void()> cb ,bool recurring = false)
addTimer	rainbow/timer.h	/^    void addTimer(Timer::ptr val, RWMutexType::WriteLock& lock);$/;"	p	class:rainbow::TimerManager	access:protected	signature:(Timer::ptr val, RWMutexType::WriteLock& lock)
appenders	rainbow/log.cpp	/^    std::vector<LogAppenderDefine> appenders;$/;"	m	struct:rainbow::LogDefine	file:	access:public
back	rainbow/fiber.cpp	/^void Fiber::back() {$/;"	f	class:rainbow::Fiber	signature:()
back	rainbow/fiber.h	/^    void back();$/;"	p	class:rainbow::Fiber	access:public	signature:()
call	rainbow/fiber.cpp	/^void Fiber::call() {$/;"	f	class:rainbow::Fiber	signature:()
call	rainbow/fiber.h	/^    void call();$/;"	p	class:rainbow::Fiber	access:public	signature:()
cancel	rainbow/timer.cpp	/^bool Timer::cancel() {$/;"	f	class:rainbow::Timer	signature:()
cancel	rainbow/timer.h	/^    bool cancel();$/;"	p	class:rainbow::Timer	access:private	signature:()
cancelAll	rainbow/iomanager.cpp	/^bool IOManager::cancelAll(int fd) {$/;"	f	class:rainbow::IOManager	signature:(int fd)
cancelAll	rainbow/iomanager.h	/^    bool cancelAll(int fd);$/;"	p	class:rainbow::IOManager	access:public	signature:(int fd)
cancelEvent	rainbow/iomanager.cpp	/^bool IOManager::cancelEvent(int fd, Event event) {$/;"	f	class:rainbow::IOManager	signature:(int fd, Event event)
cancelEvent	rainbow/iomanager.h	/^    bool cancelEvent(int fd, Event event);$/;"	p	class:rainbow::IOManager	access:public	signature:(int fd, Event event)
cb	rainbow/iomanager.h	/^            std::function<void()> cb;       \/\/ äºä»¶çåè°å½æ°$/;"	m	struct:rainbow::IOManager::FdContext::EventContext	access:public
cb	rainbow/scheduler.h	/^        std::function<void()> cb;$/;"	m	struct:rainbow::Scheduler::FiberAndThread	access:public
clearAppenders	rainbow/log.cpp	/^void Logger::clearAppenders() {$/;"	f	class:rainbow::Logger	signature:()
clearAppenders	rainbow/log.h	/^    void clearAppenders();$/;"	p	class:rainbow::Logger	access:public	signature:()
clearListener	rainbow/config.h	/^    void clearListener() {$/;"	f	class:rainbow::ConfigVar	access:public	signature:()
contextResize	rainbow/iomanager.cpp	/^void IOManager::contextResize(size_t size) {$/;"	f	class:rainbow::IOManager	signature:(size_t size)
contextResize	rainbow/iomanager.h	/^    void contextResize(size_t size);$/;"	p	class:rainbow::IOManager	access:protected	signature:(size_t size)
count	tests/test_thread.cpp	/^int count = 0;$/;"	v
debug	rainbow/log.cpp	/^void Logger::debug(LogEvent::ptr event) { log(LogLevel::DEBUG, event); }$/;"	f	class:rainbow::Logger	signature:(LogEvent::ptr event)
debug	rainbow/log.h	/^    void debug(LogEvent::ptr event);$/;"	p	class:rainbow::Logger	access:public	signature:(LogEvent::ptr event)
delAppender	rainbow/log.cpp	/^void Logger::delAppender(LogAppender::ptr appender) {$/;"	f	class:rainbow::Logger	signature:(LogAppender::ptr appender)
delAppender	rainbow/log.h	/^    void delAppender(LogAppender::ptr appender);$/;"	p	class:rainbow::Logger	access:public	signature:(LogAppender::ptr appender)
delEvent	rainbow/iomanager.cpp	/^bool IOManager::delEvent(int fd, Event event) {$/;"	f	class:rainbow::IOManager	signature:(int fd, Event event)
delEvent	rainbow/iomanager.h	/^    bool delEvent(int fd, Event event);$/;"	p	class:rainbow::IOManager	access:public	signature:(int fd, Event event)
delListener	rainbow/config.h	/^    void delListener(uint64_t key) {$/;"	f	class:rainbow::ConfigVar	access:public	signature:(uint64_t key)
detectClockRollover	rainbow/timer.cpp	/^bool TimerManager::detectClockRollover(uint64_t now_ms) {$/;"	f	class:rainbow::TimerManager	signature:(uint64_t now_ms)
detectClockRollover	rainbow/timer.h	/^    bool detectClockRollover(uint64_t now_ms);$/;"	p	class:rainbow::TimerManager	access:private	signature:(uint64_t now_ms)
error	rainbow/log.cpp	/^void Logger::error(LogEvent::ptr event) { log(LogLevel::ERROR, event); }$/;"	f	class:rainbow::Logger	signature:(LogEvent::ptr event)
error	rainbow/log.h	/^    void error(LogEvent::ptr event);$/;"	p	class:rainbow::Logger	access:public	signature:(LogEvent::ptr event)
events	rainbow/iomanager.h	/^        Event events = NONE;    \/\/ å·²ç»æ³¨åçäºä»¶$/;"	m	struct:rainbow::IOManager::FdContext	access:public
fatal	rainbow/log.cpp	/^void Logger::fatal(LogEvent::ptr event) { log(LogLevel::FATAL, event); }$/;"	f	class:rainbow::Logger	signature:(LogEvent::ptr event)
fatal	rainbow/log.h	/^    void fatal(LogEvent::ptr event);$/;"	p	class:rainbow::Logger	access:public	signature:(LogEvent::ptr event)
fd	rainbow/iomanager.h	/^        int fd = 0;             \/\/ äºä»¶å³èçå¥æ$/;"	m	struct:rainbow::IOManager::FdContext	access:public
fiber	rainbow/iomanager.h	/^            std::shared_ptr<Fiber> fiber;   \/\/ äºä»¶åç¨$/;"	m	struct:rainbow::IOManager::FdContext::EventContext	access:public
fiber	rainbow/scheduler.h	/^        Fiber::ptr fiber;$/;"	m	struct:rainbow::Scheduler::FiberAndThread	access:public
file	rainbow/log.cpp	/^    std::string file;$/;"	m	struct:rainbow::LogAppenderDefine	file:	access:public
format	rainbow/log.cpp	/^std::string LogFormatter::format(std::shared_ptr<Logger> logger,$/;"	f	class:rainbow::LogFormatter	signature:(std::shared_ptr<Logger> logger, LogLevel::Level level, LogEvent::ptr event)
format	rainbow/log.cpp	/^void LogEvent::format(const char* fmt, ...) {$/;"	f	class:rainbow::LogEvent	signature:(const char* fmt, ...)
format	rainbow/log.cpp	/^void LogEvent::format(const char* fmt, va_list al) {$/;"	f	class:rainbow::LogEvent	signature:(const char* fmt, va_list al)
format	rainbow/log.cpp	/^void LogFormatter::FormatItem::format(std::ostream& os,$/;"	f	class:rainbow::LogFormatter::FormatItem	signature:(std::ostream& os, std::shared_ptr<Logger> logger, LogLevel::Level level, LogEvent::ptr event)
format	rainbow/log.h	/^        virtual void format(std::ostream& os, std::shared_ptr<Logger> logger,$/;"	p	class:rainbow::LogFormatter::FormatItem	access:public	signature:(std::ostream& os, std::shared_ptr<Logger> logger, LogLevel::Level level, LogEvent::ptr event)
format	rainbow/log.h	/^    std::ostream& format(std::ostream& ofs, std::shared_ptr<Logger> ptr, LogLevel::Level level, LogEvent::ptr event);$/;"	p	class:rainbow::LogFormatter	access:public	signature:(std::ostream& ofs, std::shared_ptr<Logger> ptr, LogLevel::Level level, LogEvent::ptr event)
format	rainbow/log.h	/^    std::string format(std::shared_ptr<Logger> ptr, LogLevel::Level level,$/;"	p	class:rainbow::LogFormatter	access:public	signature:(std::shared_ptr<Logger> ptr, LogLevel::Level level, LogEvent::ptr event)
format	rainbow/log.h	/^    void format(const char* fmt, ...);$/;"	p	class:rainbow::LogEvent	access:public	signature:(const char* fmt, ...)
format	rainbow/log.h	/^    void format(const char* fmt, va_list al);$/;"	p	class:rainbow::LogEvent	access:public	signature:(const char* fmt, va_list al)
formatter	rainbow/log.cpp	/^    std::string formatter;$/;"	m	struct:rainbow::LogAppenderDefine	file:	access:public
formatter	rainbow/log.cpp	/^    std::string formatter;$/;"	m	struct:rainbow::LogDefine	file:	access:public
fromString	rainbow/config.h	/^    virtual bool fromString(const std::string& val) = 0;$/;"	p	class:rainbow::ConfigVarBase	access:public	signature:(const std::string& val)
fun1	tests/test_thread.cpp	/^void fun1() {$/;"	f	signature:()
fun2	tests/test_thread.cpp	/^void fun2() {$/;"	f	signature:()
fun3	tests/test_thread.cpp	/^void fun3() {$/;"	f	signature:()
g_fiber_stack_size	rainbow/fiber.cpp	/^static ConfigVar<uint32_t>::ptr g_fiber_stack_size = $/;"	m	namespace:rainbow	file:
g_log_define	rainbow/log.cpp	/^rainbow::ConfigVar<std::set<LogDefine>>::ptr g_log_define = $/;"	m	namespace:rainbow	file:
g_logger	rainbow/config.cpp	/^static rainbow::Logger::ptr g_logger = RAINBOW_LOG_NAME("system");$/;"	m	namespace:rainbow	file:
g_logger	rainbow/fiber.cpp	/^static Logger::ptr g_logger = RAINBOW_LOG_NAME("system");$/;"	m	namespace:rainbow	file:
g_logger	rainbow/iomanager.cpp	/^static rainbow::Logger::ptr g_logger = RAINBOW_LOG_NAME("system");$/;"	m	namespace:rainbow	file:
g_logger	rainbow/scheduler.cpp	/^static rainbow::Logger::ptr g_logger = RAINBOW_LOG_NAME("system");$/;"	m	namespace:rainbow	file:
g_logger	rainbow/thread.cpp	/^static rainbow::Logger::ptr g_logger = RAINBOW_LOG_NAME("system");$/;"	m	namespace:rainbow	file:
g_logger	rainbow/util.cpp	/^rainbow::Logger::ptr g_logger = RAINBOW_LOG_NAME("system");$/;"	m	namespace:rainbow	file:
g_logger	tests/test_fiber.cpp	/^rainbow::Logger::ptr g_logger = RAINBOW_LOG_ROOT();$/;"	v
g_logger	tests/test_iomanager.cpp	/^rainbow::Logger::ptr g_logger = RAINBOW_LOG_ROOT();$/;"	v
g_logger	tests/test_scheduler.cpp	/^rainbow::Logger::ptr g_logger = RAINBOW_LOG_ROOT();$/;"	v
g_logger	tests/test_thread.cpp	/^rainbow::Logger::ptr g_logger = RAINBOW_LOG_ROOT();$/;"	v
g_logger	tests/test_util.cpp	/^rainbow::Logger::ptr g_logger = RAINBOW_LOG_ROOT();$/;"	v
g_person_map	tests/test_config.cpp	/^rainbow::ConfigVar<std::map<std::string, Person>>::ptr g_person_map = $/;"	v
g_person_map_vec	tests/test_config.cpp	/^rainbow::ConfigVar<std::map<std::string, std::vector<Person>>>::ptr g_person_map_vec = $/;"	v
getContent	rainbow/log.h	/^    std::string getContent() const { return m_ss.str(); }$/;"	f	class:rainbow::LogEvent	access:public	signature:() const
getContext	rainbow/iomanager.cpp	/^IOManager::FdContext::EventContext& IOManager::FdContext::getContext(IOManager::Event event) {$/;"	f	class:rainbow::IOManager::FdContext	signature:(IOManager::Event event)
getContext	rainbow/iomanager.h	/^        EventContext& getContext(Event event);$/;"	p	struct:rainbow::IOManager::FdContext	access:public	signature:(Event event)
getDescription	rainbow/config.h	/^    const std::string& getDescription() const { return m_description; }$/;"	f	class:rainbow::ConfigVarBase	access:public	signature:() const
getElapse	rainbow/log.h	/^    uint32_t getElapse() const { return m_elapse; }$/;"	f	class:rainbow::LogEvent	access:public	signature:() const
getEvent	rainbow/log.h	/^    LogEvent::ptr getEvent() const { return m_event; }$/;"	f	class:rainbow::LogEventWrap	access:public	signature:() const
getFiberId	rainbow/log.h	/^    uint32_t getFiberId() const { return m_fiberId; }$/;"	f	class:rainbow::LogEvent	access:public	signature:() const
getFileName	rainbow/log.h	/^    const char* getFileName() const { return m_file; }$/;"	f	class:rainbow::LogEvent	access:public	signature:() const
getFormatter	rainbow/log.cpp	/^LogFormatter::ptr LogAppender::getFormatter() {$/;"	f	class:rainbow::LogAppender	signature:()
getFormatter	rainbow/log.cpp	/^LogFormatter::ptr Logger::getFormatter() {$/;"	f	class:rainbow::Logger	signature:()
getFormatter	rainbow/log.h	/^    LogFormatter::ptr getFormatter(); $/;"	p	class:rainbow::LogAppender	access:public	signature:()
getFormatter	rainbow/log.h	/^    LogFormatter::ptr getFormatter();$/;"	p	class:rainbow::Logger	access:public	signature:()
getId	rainbow/thread.h	/^    pid_t getId() const { return m_id; }$/;"	f	class:rainbow::Thread	access:public	signature:() const
getLevel	rainbow/log.h	/^    LogLevel::Level getLevel() const { return m_level; }$/;"	f	class:rainbow::LogAppender	access:public	signature:() const
getLevel	rainbow/log.h	/^    LogLevel::Level getLevel() const { return m_level; }$/;"	f	class:rainbow::LogEvent	access:public	signature:() const
getLevel	rainbow/log.h	/^    LogLevel::Level getLevel() const { return m_level; }$/;"	f	class:rainbow::Logger	access:public	signature:() const
getLine	rainbow/log.h	/^    int32_t getLine() const { return m_line; }$/;"	f	class:rainbow::LogEvent	access:public	signature:() const
getListener	rainbow/config.h	/^    on_change_cb getListener(uint64_t key) {$/;"	f	class:rainbow::ConfigVar	access:public	signature:(uint64_t key)
getLogger	rainbow/log.cpp	/^Logger::ptr LoggerManager::getLogger(const std::string& name) {$/;"	f	class:rainbow::LoggerManager	signature:(const std::string& name)
getLogger	rainbow/log.h	/^    Logger::ptr getLogger(const std::string& name);$/;"	p	class:rainbow::LoggerManager	access:public	signature:(const std::string& name)
getLogger	rainbow/log.h	/^    std::shared_ptr<Logger> getLogger() const {  return m_logger; }$/;"	f	class:rainbow::LogEvent	access:public	signature:() const
getName	rainbow/config.h	/^    const std::string& getName() const { return m_name; }$/;"	f	class:rainbow::ConfigVarBase	access:public	signature:() const
getName	rainbow/log.h	/^    const std::string getName() const { return this->m_name; }$/;"	f	class:rainbow::Logger	access:public	signature:() const
getName	rainbow/scheduler.h	/^    const std::string& getName() const { return m_name; }$/;"	f	class:rainbow::Scheduler	access:public	signature:() const
getName	rainbow/thread.h	/^    const std::string& getName() const { return m_name; }$/;"	f	class:rainbow::Thread	access:public	signature:() const
getNextTimer	rainbow/timer.cpp	/^uint64_t TimerManager::getNextTimer() {$/;"	f	class:rainbow::TimerManager	signature:()
getNextTimer	rainbow/timer.h	/^    uint64_t getNextTimer();$/;"	p	class:rainbow::TimerManager	access:public	signature:()
getPattern	rainbow/log.h	/^    const std::string getPattern() const { return m_pattern; }$/;"	f	class:rainbow::LogFormatter	access:public	signature:() const
getRoot	rainbow/log.h	/^    Logger::ptr getRoot() const { return m_root; }$/;"	f	class:rainbow::LoggerManager	access:public	signature:() const
getSS	rainbow/log.cpp	/^std::stringstream& LogEventWrap::getSS() {$/;"	f	class:rainbow::LogEventWrap	signature:()
getSS	rainbow/log.h	/^    std::stringstream& getSS() { return m_ss; }$/;"	f	class:rainbow::LogEvent	access:public	signature:()
getSS	rainbow/log.h	/^    std::stringstream& getSS();$/;"	p	class:rainbow::LogEventWrap	access:public	signature:()
getState	rainbow/fiber.h	/^    uint64_t getState() const { return m_state; }$/;"	f	class:rainbow::Fiber	access:public	signature:() const
getString	rainbow/log.cpp	/^    std::string getString() const { return m_string; }$/;"	f	class:rainbow::StringFormatItem	access:public	signature:() const
getThreadId	rainbow/log.h	/^    uint32_t getThreadId() const { return m_threadId; }$/;"	f	class:rainbow::LogEvent	access:public	signature:() const
getThreadName	rainbow/log.h	/^    const std::string& getThreadName() { return m_threadName; }$/;"	f	class:rainbow::LogEvent	access:public	signature:()
getTime	rainbow/log.h	/^    uint32_t getTime() const { return m_time; }$/;"	f	class:rainbow::LogEvent	access:public	signature:() const
getTypeName	rainbow/config.h	/^    virtual std::string getTypeName() const = 0;$/;"	p	class:rainbow::ConfigVarBase	access:public	signature:() const
getValue	rainbow/config.h	/^    const T getValue() { $/;"	f	class:rainbow::ConfigVar	access:public	signature:()
hasIdleThreads	rainbow/scheduler.h	/^    bool hasIdleThreads() { return m_idleThreadCount > 0; }$/;"	f	class:rainbow::Scheduler	access:protected	signature:()
hasTimer	rainbow/timer.cpp	/^bool TimerManager::hasTimer() {$/;"	f	class:rainbow::TimerManager	signature:()
hasTimer	rainbow/timer.h	/^    bool hasTimer();$/;"	p	class:rainbow::TimerManager	access:protected	signature:()
idle	rainbow/iomanager.cpp	/^void IOManager::idle() {$/;"	f	class:rainbow::IOManager	signature:()
idle	rainbow/scheduler.cpp	/^void Scheduler::idle() {$/;"	f	class:rainbow::Scheduler	signature:()
idle	rainbow/scheduler.h	/^    virtual void idle();$/;"	p	class:rainbow::Scheduler	access:protected	signature:()
incdirs	Makefile	/^incdirs := rainbow$/;"	m
info	rainbow/log.cpp	/^void Logger::info(LogEvent::ptr event) { log(LogLevel::INFO, event); }$/;"	f	class:rainbow::Logger	signature:(LogEvent::ptr event)
info	rainbow/log.h	/^    void info(LogEvent::ptr event);$/;"	p	class:rainbow::Logger	access:public	signature:(LogEvent::ptr event)
init	rainbow/log.cpp	/^void LogFormatter::init() {$/;"	f	class:rainbow::LogFormatter	signature:()
init	rainbow/log.cpp	/^void LoggerManager::init() {$/;"	f	class:rainbow::LoggerManager	signature:()
init	rainbow/log.h	/^    void init();$/;"	p	class:rainbow::LogFormatter	access:public	signature:()
init	rainbow/log.h	/^    void init();$/;"	p	class:rainbow::LoggerManager	access:public	signature:()
isError	rainbow/log.h	/^    bool isError() const {$/;"	f	class:rainbow::LogFormatter	access:public	signature:() const
join	rainbow/thread.cpp	/^void Thread::join() {$/;"	f	class:rainbow::Thread	signature:()
join	rainbow/thread.h	/^    void join();$/;"	p	class:rainbow::Thread	access:public	signature:()
level	rainbow/log.cpp	/^    LogLevel::Level level = LogLevel::UNKNOW;$/;"	m	struct:rainbow::LogAppenderDefine	file:	access:public
level	rainbow/log.cpp	/^    LogLevel::Level level = LogLevel::UNKNOW;$/;"	m	struct:rainbow::LogDefine	file:	access:public
listExpiredCb	rainbow/timer.cpp	/^void TimerManager::listExpiredCb(std::vector<std::function<void()>>& cbs) {$/;"	f	class:rainbow::TimerManager	signature:(std::vector<std::function<void()>>& cbs)
listExpiredCb	rainbow/timer.h	/^    void listExpiredCb(std::vector<std::function<void()>>& cbs);$/;"	p	class:rainbow::TimerManager	access:public	signature:(std::vector<std::function<void()>>& cbs)
lock	rainbow/thread.h	/^    void lock() {$/;"	f	class:rainbow::CASLock	access:public	signature:()
lock	rainbow/thread.h	/^    void lock() {$/;"	f	class:rainbow::Mutex	access:public	signature:()
lock	rainbow/thread.h	/^    void lock() {$/;"	f	class:rainbow::Spinlock	access:public	signature:()
lock	rainbow/thread.h	/^    void lock() {$/;"	f	struct:rainbow::ReadScopedLockImpl	access:public	signature:()
lock	rainbow/thread.h	/^    void lock() {$/;"	f	struct:rainbow::ScopedLockImpl	access:public	signature:()
lock	rainbow/thread.h	/^    void lock() {$/;"	f	struct:rainbow::WriteScopedLockImpl	access:public	signature:()
lock	rainbow/thread.h	/^    void lock() {}$/;"	f	class:rainbow::NullMutex	access:public	signature:()
log	rainbow/log.cpp	/^void FileLogAppender::log(std::shared_ptr<Logger> logger, LogLevel::Level level,$/;"	f	class:rainbow::FileLogAppender	signature:(std::shared_ptr<Logger> logger, LogLevel::Level level, LogEvent::ptr event)
log	rainbow/log.cpp	/^void Logger::log(LogLevel::Level level, LogEvent::ptr event) {$/;"	f	class:rainbow::Logger	signature:(LogLevel::Level level, LogEvent::ptr event)
log	rainbow/log.cpp	/^void StdoutLogAppender::log(std::shared_ptr<Logger> logger,$/;"	f	class:rainbow::StdoutLogAppender	signature:(std::shared_ptr<Logger> logger, LogLevel::Level level, LogEvent::ptr event)
log	rainbow/log.h	/^    virtual void log(std::shared_ptr<Logger> logger, LogLevel::Level level,$/;"	p	class:rainbow::LogAppender	access:public	signature:(std::shared_ptr<Logger> logger, LogLevel::Level level, LogEvent::ptr event)
log	rainbow/log.h	/^    void log(LogLevel::Level level, LogEvent::ptr event);$/;"	p	class:rainbow::Logger	access:public	signature:(LogLevel::Level level, LogEvent::ptr event)
m_activeThreadCount	rainbow/scheduler.h	/^    std::atomic<size_t> m_activeThreadCount = {0};$/;"	m	class:rainbow::Scheduler	access:protected
m_age	tests/test_config.cpp	/^    int m_age = 0;$/;"	m	class:Person	file:	access:public
m_appenders	rainbow/log.h	/^    std::list<LogAppender::ptr> m_appenders;  \/\/ Appenderéå$/;"	m	class:rainbow::Logger	access:private
m_autoStop	rainbow/scheduler.h	/^    bool m_autoStop = false;$/;"	m	class:rainbow::Scheduler	access:protected
m_cb	rainbow/fiber.h	/^    std::function<void()> m_cb;$/;"	m	class:rainbow::Fiber	access:private
m_cb	rainbow/thread.h	/^    std::function<void()> m_cb;$/;"	m	class:rainbow::Thread	access:private
m_cb	rainbow/timer.h	/^    std::function<void()> m_cb;$/;"	m	class:rainbow::Timer	access:private
m_cbs	rainbow/config.h	/^    std::map<uint64_t, on_change_cb> m_cbs;$/;"	m	class:rainbow::ConfigVar	access:private
m_ctx	rainbow/fiber.h	/^    ucontext_t m_ctx;$/;"	m	class:rainbow::Fiber	access:private
m_description	rainbow/config.h	/^    std::string m_description;$/;"	m	class:rainbow::ConfigVarBase	access:protected
m_elapse	rainbow/log.h	/^    uint32_t m_elapse = 0;         \/\/ ç¨åºå¯å¨å¼å§å°ç°å¨çæ¯«ç§æ°$/;"	m	class:rainbow::LogEvent	access:private
m_epfd	rainbow/iomanager.h	/^    int m_epfd = 0;$/;"	m	class:rainbow::IOManager	access:private
m_error	rainbow/log.h	/^    bool m_error = false;$/;"	m	class:rainbow::LogFormatter	access:private
m_event	rainbow/log.h	/^    LogEvent::ptr m_event;$/;"	m	class:rainbow::LogEventWrap	access:private
m_fdContexts	rainbow/iomanager.h	/^    std::vector<FdContext*> m_fdContexts;$/;"	m	class:rainbow::IOManager	access:private
m_fiberId	rainbow/log.h	/^    uint32_t m_fiberId = 0;        \/\/ åç¨id$/;"	m	class:rainbow::LogEvent	access:private
m_fibers	rainbow/scheduler.h	/^    std::list<FiberAndThread> m_fibers;$/;"	m	class:rainbow::Scheduler	access:private
m_file	rainbow/log.h	/^    const char* m_file = nullptr;  \/\/ æä»¶å$/;"	m	class:rainbow::LogEvent	access:private
m_filename	rainbow/log.h	/^    std::string m_filename;$/;"	m	class:rainbow::FileLogAppender	access:private
m_filestream	rainbow/log.h	/^    std::ofstream m_filestream;$/;"	m	class:rainbow::FileLogAppender	access:private
m_format	rainbow/log.cpp	/^    std::string m_format;$/;"	m	class:rainbow::DateTimeFormatItem	file:	access:private
m_formatter	rainbow/log.h	/^    LogFormatter::ptr m_formatter;            \/\/ æ¥å¿æ ¼å¼$/;"	m	class:rainbow::Logger	access:private
m_formatter	rainbow/log.h	/^    LogFormatter::ptr m_formatter;$/;"	m	class:rainbow::LogAppender	access:protected
m_hasFormatter	rainbow/log.h	/^    bool m_hasFormatter = false;$/;"	m	class:rainbow::LogAppender	access:protected
m_id	rainbow/fiber.h	/^    uint64_t m_id = 0;$/;"	m	class:rainbow::Fiber	access:private
m_id	rainbow/thread.h	/^    pid_t m_id;$/;"	m	class:rainbow::Thread	access:private
m_idleThreadCount	rainbow/scheduler.h	/^    std::atomic<size_t> m_idleThreadCount = {0};$/;"	m	class:rainbow::Scheduler	access:protected
m_items	rainbow/log.h	/^    std::vector<FormatItem::ptr> m_items;$/;"	m	class:rainbow::LogFormatter	access:private
m_lastTime	rainbow/log.h	/^    uint64_t m_lastTime = 0;$/;"	m	class:rainbow::FileLogAppender	access:private
m_level	rainbow/log.h	/^    LogLevel::Level m_level = LogLevel::DEBUG;$/;"	m	class:rainbow::LogAppender	access:protected
m_level	rainbow/log.h	/^    LogLevel::Level m_level;            \/\/ è¯¥æ¥å¿äºä»¶ççº§å«$/;"	m	class:rainbow::LogEvent	access:private
m_level	rainbow/log.h	/^    LogLevel::Level m_level;  \/\/ æ¥å¿å¨ççº§å«$/;"	m	class:rainbow::Logger	access:private
m_line	rainbow/log.h	/^    int32_t m_line = 0;            \/\/ è¡å·$/;"	m	class:rainbow::LogEvent	access:private
m_lock	rainbow/thread.h	/^    pthread_rwlock_t m_lock;$/;"	m	class:rainbow::RWMutex	access:private
m_locked	rainbow/thread.h	/^    bool m_locked;$/;"	m	struct:rainbow::ReadScopedLockImpl	access:private
m_locked	rainbow/thread.h	/^    bool m_locked;$/;"	m	struct:rainbow::ScopedLockImpl	access:private
m_locked	rainbow/thread.h	/^    bool m_locked;$/;"	m	struct:rainbow::WriteScopedLockImpl	access:private
m_logger	rainbow/log.h	/^    std::shared_ptr<Logger> m_logger;   \/\/ æå Logger ç±»çæé$/;"	m	class:rainbow::LogEvent	access:private
m_loggers	rainbow/log.h	/^    std::map<std::string, Logger::ptr> m_loggers;$/;"	m	class:rainbow::LoggerManager	access:private
m_manager	rainbow/timer.h	/^    TimerManager* m_manager = nullptr;$/;"	m	class:rainbow::Timer	access:private
m_ms	rainbow/timer.h	/^    uint64_t m_ms = 0; $/;"	m	class:rainbow::Timer	access:private
m_mutex	rainbow/config.h	/^    RWMutexType m_mutex;$/;"	m	class:rainbow::ConfigVar	access:private
m_mutex	rainbow/iomanager.h	/^    RWMutexType m_mutex;$/;"	m	class:rainbow::IOManager	access:private
m_mutex	rainbow/log.h	/^    MutexType m_mutex;$/;"	m	class:rainbow::LogAppender	access:protected
m_mutex	rainbow/log.h	/^    MutexType m_mutex;$/;"	m	class:rainbow::Logger	access:private
m_mutex	rainbow/log.h	/^    MutexType m_mutex;$/;"	m	class:rainbow::LoggerManager	access:private
m_mutex	rainbow/scheduler.h	/^    MutexType m_mutex;$/;"	m	class:rainbow::Scheduler	access:private
m_mutex	rainbow/thread.h	/^    T& m_mutex;$/;"	m	struct:rainbow::ReadScopedLockImpl	access:private
m_mutex	rainbow/thread.h	/^    T& m_mutex;$/;"	m	struct:rainbow::ScopedLockImpl	access:private
m_mutex	rainbow/thread.h	/^    T& m_mutex;$/;"	m	struct:rainbow::WriteScopedLockImpl	access:private
m_mutex	rainbow/thread.h	/^    pthread_mutex_t m_mutex;$/;"	m	class:rainbow::Mutex	access:private
m_mutex	rainbow/thread.h	/^    pthread_spinlock_t m_mutex;$/;"	m	class:rainbow::Spinlock	access:private
m_mutex	rainbow/thread.h	/^    volatile std::atomic_flag m_mutex;$/;"	m	class:rainbow::CASLock	access:private
m_mutex	rainbow/timer.h	/^    RWMutexType m_mutex;$/;"	m	class:rainbow::TimerManager	access:private
m_name	rainbow/config.h	/^    std::string m_name;$/;"	m	class:rainbow::ConfigVarBase	access:protected
m_name	rainbow/log.h	/^    std::string m_name;       \/\/ æ¥å¿åç§°$/;"	m	class:rainbow::Logger	access:private
m_name	rainbow/scheduler.h	/^    std::string m_name;$/;"	m	class:rainbow::Scheduler	access:private
m_name	rainbow/thread.h	/^    std::string m_name;$/;"	m	class:rainbow::Thread	access:private
m_name	tests/test_config.cpp	/^    std::string m_name;$/;"	m	class:Person	file:	access:public
m_next	rainbow/timer.h	/^    uint64_t m_next = 0;$/;"	m	class:rainbow::Timer	access:private
m_pattern	rainbow/log.h	/^    std::string m_pattern;$/;"	m	class:rainbow::LogFormatter	access:private
m_pendingEventCount	rainbow/iomanager.h	/^    std::atomic<size_t> m_pendingEventCount = {0};$/;"	m	class:rainbow::IOManager	access:private
m_previouseTime	rainbow/timer.h	/^    uint64_t m_previouseTime = 0;$/;"	m	class:rainbow::TimerManager	access:private
m_recurring	rainbow/timer.h	/^    bool m_recurring = false;$/;"	m	class:rainbow::Timer	access:private
m_root	rainbow/log.h	/^    Logger::ptr m_root;$/;"	m	class:rainbow::Logger	access:private
m_root	rainbow/log.h	/^    Logger::ptr m_root;$/;"	m	class:rainbow::LoggerManager	access:private
m_rootFiber	rainbow/scheduler.h	/^    Fiber::ptr m_rootFiber;$/;"	m	class:rainbow::Scheduler	access:private
m_rootThread	rainbow/scheduler.h	/^    int m_rootThread = 0;$/;"	m	class:rainbow::Scheduler	access:protected
m_semaphore	rainbow/thread.h	/^    Semaphore m_semaphore;$/;"	m	class:rainbow::Thread	access:private
m_semaphore	rainbow/thread.h	/^    sem_t m_semaphore;$/;"	m	class:rainbow::Semaphore	access:private
m_sex	tests/test_config.cpp	/^    bool m_sex = 0;$/;"	m	class:Person	file:	access:public
m_ss	rainbow/log.h	/^    std::stringstream m_ss;             \/\/ æ¥å¿æµ$/;"	m	class:rainbow::LogEvent	access:private
m_stack	rainbow/fiber.h	/^    void* m_stack = nullptr;$/;"	m	class:rainbow::Fiber	access:private
m_stacksize	rainbow/fiber.h	/^    uint32_t m_stacksize = 0;$/;"	m	class:rainbow::Fiber	access:private
m_state	rainbow/fiber.h	/^    State m_state = INIT;$/;"	m	class:rainbow::Fiber	access:private
m_stopping	rainbow/scheduler.h	/^    bool m_stopping = true;$/;"	m	class:rainbow::Scheduler	access:protected
m_string	rainbow/log.cpp	/^    std::string m_string;$/;"	m	class:rainbow::StringFormatItem	file:	access:private
m_thread	rainbow/thread.h	/^    pthread_t m_thread;$/;"	m	class:rainbow::Thread	access:private
m_threadCount	rainbow/scheduler.h	/^    size_t m_threadCount = 0;$/;"	m	class:rainbow::Scheduler	access:protected
m_threadId	rainbow/log.h	/^    uint32_t m_threadId = 0;       \/\/ çº¿ç¨id$/;"	m	class:rainbow::LogEvent	access:private
m_threadIds	rainbow/scheduler.h	/^    std::vector<int> m_threadIds;$/;"	m	class:rainbow::Scheduler	access:protected
m_threadName	rainbow/log.h	/^    std::string m_threadName;$/;"	m	class:rainbow::LogEvent	access:private
m_threads	rainbow/scheduler.h	/^    std::vector<Thread::ptr> m_threads;$/;"	m	class:rainbow::Scheduler	access:private
m_tickleFds	rainbow/iomanager.h	/^    int m_tickleFds[2];$/;"	m	class:rainbow::IOManager	access:private
m_tickled	rainbow/timer.h	/^    bool m_tickled = false;$/;"	m	class:rainbow::TimerManager	access:private
m_time	rainbow/log.h	/^    uint64_t m_time;               \/\/ æ¶é´æ³$/;"	m	class:rainbow::LogEvent	access:private
m_timers	rainbow/timer.h	/^    std::set<Timer::ptr, Timer::Comparator> m_timers;$/;"	m	class:rainbow::TimerManager	access:private
m_val	rainbow/config.h	/^    T m_val;$/;"	m	class:rainbow::ConfigVar	access:private
main	tests/test.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	tests/test_config.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	tests/test_fiber.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	tests/test_iomanager.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	tests/test_scheduler.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
main	tests/test_thread.cpp	/^int main(int argc, char** argv) {$/;"	f	signature:(int argc, char** argv)
main	tests/test_util.cpp	/^int main(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
mutex	rainbow/iomanager.h	/^        MutexType mutex;$/;"	m	struct:rainbow::IOManager::FdContext	access:public
name	rainbow/log.cpp	/^    std::string name;$/;"	m	struct:rainbow::LogDefine	file:	access:public
notify	rainbow/thread.cpp	/^void Semaphore::notify() {$/;"	f	class:rainbow::Semaphore	signature:()
notify	rainbow/thread.h	/^    void notify();$/;"	p	class:rainbow::Semaphore	access:public	signature:()
obj_dir	Makefile	/^obj_dir := .\/obj$/;"	m
objdir	Makefile	/^objdir := obj$/;"	m
objlist	Makefile	/^objlist := $(patsubst %.cpp, $(objdir)\/%.o, $(srcs))$/;"	m
onTimerInsertedAtFront	rainbow/iomanager.cpp	/^void IOManager::onTimerInsertedAtFront() {$/;"	f	class:rainbow::IOManager	signature:()
onTimerInsertedAtFront	rainbow/timer.h	/^    virtual void onTimerInsertedAtFront() = 0;$/;"	p	class:rainbow::TimerManager	access:protected	signature:()
on_change_cb	rainbow/config.h	/^    typedef std::function<void (const T& old_value, const T& new_value)> on_change_cb;$/;"	t	class:rainbow::ConfigVar	access:public
operator ()	rainbow/config.h	/^    T operator()(const F& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const F& v)
operator ()	rainbow/config.h	/^    std::list<T> operator()(const std::string& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::string& v)
operator ()	rainbow/config.h	/^    std::map<std::string, T> operator()(const std::string& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::string& v)
operator ()	rainbow/config.h	/^    std::set<T> operator()(const std::string& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::string& v)
operator ()	rainbow/config.h	/^    std::string operator()(const std::list<T>& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::list<T>& v)
operator ()	rainbow/config.h	/^    std::string operator()(const std::map<std::string, T>& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::map<std::string, T>& v)
operator ()	rainbow/config.h	/^    std::string operator()(const std::set<T>& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::set<T>& v)
operator ()	rainbow/config.h	/^    std::string operator()(const std::unordered_map<std::string, T>& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::unordered_map<std::string, T>& v)
operator ()	rainbow/config.h	/^    std::string operator()(const std::unordered_set<T>& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::unordered_set<T>& v)
operator ()	rainbow/config.h	/^    std::string operator()(const std::vector<T>& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::vector<T>& v)
operator ()	rainbow/config.h	/^    std::unordered_map<std::string, T> operator()(const std::string& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::string& v)
operator ()	rainbow/config.h	/^    std::unordered_set<T> operator()(const std::string& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::string& v)
operator ()	rainbow/config.h	/^    std::vector<T> operator()(const std::string& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::string& v)
operator ()	rainbow/log.cpp	/^    std::set<LogDefine> operator()(const std::string& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::string& v)
operator ()	rainbow/log.cpp	/^    std::string operator()(const std::set<LogDefine>& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::set<LogDefine>& v)
operator ()	rainbow/timer.cpp	/^bool Timer::Comparator::operator()(const Timer::ptr& lhs$/;"	f	class:rainbow::Timer::Comparator	signature:(const Timer::ptr& lhs ,const Timer::ptr& rhs) const
operator ()	rainbow/timer.h	/^        bool operator() (const Timer::ptr& lhs, const Timer::ptr& rhs) const;$/;"	p	struct:rainbow::Timer::Comparator	access:public	signature:(const Timer::ptr& lhs, const Timer::ptr& rhs) const
operator ()	tests/test_config.cpp	/^    Person operator()(const std::string& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::string& v)
operator ()	tests/test_config.cpp	/^    std::string operator()(const Person& p) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const Person& p)
operator <	rainbow/log.cpp	/^    bool operator<(const LogDefine& oth) const {$/;"	f	struct:rainbow::LogDefine	access:public	signature:(const LogDefine& oth) const
operator =	rainbow/thread.h	/^    Semaphore& operator=(const Semaphore&) = delete;$/;"	p	class:rainbow::Semaphore	access:private	signature:(const Semaphore&)
operator =	rainbow/thread.h	/^    Thread& operator=(const Thread&) = delete;$/;"	p	class:rainbow::Thread	access:private	signature:(const Thread&)
operator ==	rainbow/log.cpp	/^    bool operator==(const LogAppenderDefine& oth) const {$/;"	f	struct:rainbow::LogAppenderDefine	access:public	signature:(const LogAppenderDefine& oth) const
operator ==	rainbow/log.cpp	/^    bool operator==(const LogDefine& oth) const {$/;"	f	struct:rainbow::LogDefine	access:public	signature:(const LogDefine& oth) const
operator ==	tests/test_config.cpp	/^    bool operator==(const Person& oth) const {$/;"	f	class:Person	access:public	signature:(const Person& oth) const
override	rainbow/iomanager.h	/^    bool stopping() override;$/;"	m	class:rainbow::IOManager	access:protected
override	rainbow/iomanager.h	/^    void idle() override;$/;"	m	class:rainbow::IOManager	access:protected
override	rainbow/iomanager.h	/^    void onTimerInsertedAtFront() override;$/;"	m	class:rainbow::IOManager	access:protected
override	rainbow/iomanager.h	/^    void tickle() override;$/;"	m	class:rainbow::IOManager	access:protected
override	rainbow/log.h	/^                     LogEvent::ptr event) override;$/;"	m	class:rainbow::FileLogAppender	access:public
override	rainbow/log.h	/^                     LogEvent::ptr event) override;$/;"	m	class:rainbow::StdoutLogAppender	access:public
override	rainbow/log.h	/^    std::string toYamlString() override;$/;"	m	class:rainbow::FileLogAppender	access:public
override	rainbow/log.h	/^    std::string toYamlString() override;$/;"	m	class:rainbow::StdoutLogAppender	access:public
ptr	rainbow/config.h	/^    typedef std::shared_ptr<ConfigVar> ptr;$/;"	t	class:rainbow::ConfigVar	access:public
ptr	rainbow/config.h	/^    typedef std::shared_ptr<ConfigVarBase> ptr;$/;"	t	class:rainbow::ConfigVarBase	access:public
ptr	rainbow/fiber.h	/^    typedef std::shared_ptr<Fiber> ptr;$/;"	t	class:rainbow::Fiber	access:public
ptr	rainbow/iomanager.h	/^    typedef std::shared_ptr<IOManager> ptr;$/;"	t	class:rainbow::IOManager	access:public
ptr	rainbow/log.h	/^        typedef std::shared_ptr<FormatItem> ptr;$/;"	t	class:rainbow::LogFormatter::FormatItem	access:public
ptr	rainbow/log.h	/^    typedef std::shared_ptr<FileLogAppender> ptr;$/;"	t	class:rainbow::FileLogAppender	access:public
ptr	rainbow/log.h	/^    typedef std::shared_ptr<LogAppender> ptr;$/;"	t	class:rainbow::LogAppender	access:public
ptr	rainbow/log.h	/^    typedef std::shared_ptr<LogEvent> ptr;$/;"	t	class:rainbow::LogEvent	access:public
ptr	rainbow/log.h	/^    typedef std::shared_ptr<LogFormatter> ptr;$/;"	t	class:rainbow::LogFormatter	access:public
ptr	rainbow/log.h	/^    typedef std::shared_ptr<Logger> ptr;$/;"	t	class:rainbow::Logger	access:public
ptr	rainbow/log.h	/^    typedef std::shared_ptr<StdoutLogAppender> ptr;$/;"	t	class:rainbow::StdoutLogAppender	access:public
ptr	rainbow/scheduler.h	/^    typedef std::shared_ptr<Scheduler> ptr;$/;"	t	class:rainbow::Scheduler	access:public
ptr	rainbow/thread.h	/^    typedef std::shared_ptr<Thread> ptr;$/;"	t	class:rainbow::Thread	access:public
ptr	rainbow/timer.h	/^    typedef std::shared_ptr<Timer> ptr;$/;"	t	class:rainbow::Timer	access:public
rainbow	rainbow/config.cpp	/^namespace rainbow {$/;"	n	file:
rainbow	rainbow/config.h	/^namespace rainbow {$/;"	n
rainbow	rainbow/fiber.cpp	/^namespace rainbow {$/;"	n	file:
rainbow	rainbow/fiber.h	/^namespace rainbow {$/;"	n
rainbow	rainbow/iomanager.cpp	/^namespace rainbow {$/;"	n	file:
rainbow	rainbow/iomanager.h	/^namespace rainbow {$/;"	n
rainbow	rainbow/log.cpp	/^namespace rainbow {$/;"	n	file:
rainbow	rainbow/log.h	/^namespace rainbow {$/;"	n
rainbow	rainbow/scheduler.cpp	/^namespace rainbow {$/;"	n	file:
rainbow	rainbow/scheduler.h	/^namespace rainbow {$/;"	n
rainbow	rainbow/singleton.h	/^namespace rainbow {$/;"	n
rainbow	rainbow/thread.cpp	/^namespace rainbow {$/;"	n	file:
rainbow	rainbow/thread.h	/^namespace rainbow {$/;"	n
rainbow	rainbow/timer.cpp	/^namespace rainbow {$/;"	n	file:
rainbow	rainbow/timer.h	/^namespace rainbow {$/;"	n
rainbow	rainbow/util.cpp	/^namespace rainbow {$/;"	n	file:
rainbow	rainbow/util.h	/^namespace rainbow {$/;"	n
rainbow	tests/test_config.cpp	/^namespace rainbow {$/;"	n	file:
rainbow::Backtrace	rainbow/util.cpp	/^void Backtrace(std::vector<std::string>& bt, int size, int skip) {$/;"	f	namespace:rainbow	signature:(std::vector<std::string>& bt, int size, int skip)
rainbow::Backtrace	rainbow/util.h	/^void Backtrace(std::vector<std::string>& bt, int size = 64, int skip = 1);$/;"	p	namespace:rainbow	signature:(std::vector<std::string>& bt, int size = 64, int skip = 1)
rainbow::BacktraceToString	rainbow/util.cpp	/^std::string BacktraceToString(const std::string& prefix, int size, int skip) {$/;"	f	namespace:rainbow	signature:(const std::string& prefix, int size, int skip)
rainbow::BacktraceToString	rainbow/util.h	/^std::string BacktraceToString(const std::string& prefix = "", int size = 64, int skip = 2);$/;"	p	namespace:rainbow	signature:(const std::string& prefix = Ó, int size = 64, int skip = 2)
rainbow::CASLock	rainbow/thread.h	/^class CASLock {$/;"	c	namespace:rainbow
rainbow::CASLock::CASLock	rainbow/thread.h	/^    CASLock() {$/;"	f	class:rainbow::CASLock	access:public	signature:()
rainbow::CASLock::Lock	rainbow/thread.h	/^    typedef ScopedLockImpl<CASLock> Lock;$/;"	t	class:rainbow::CASLock	access:public
rainbow::CASLock::lock	rainbow/thread.h	/^    void lock() {$/;"	f	class:rainbow::CASLock	access:public	signature:()
rainbow::CASLock::m_mutex	rainbow/thread.h	/^    volatile std::atomic_flag m_mutex;$/;"	m	class:rainbow::CASLock	access:private
rainbow::CASLock::unlock	rainbow/thread.h	/^    void unlock() {$/;"	f	class:rainbow::CASLock	access:public	signature:()
rainbow::CASLock::~CASLock	rainbow/thread.h	/^    ~CASLock() {$/;"	f	class:rainbow::CASLock	access:public	signature:()
rainbow::Config	rainbow/config.h	/^class Config {$/;"	c	namespace:rainbow
rainbow::Config::ConfigVarMap	rainbow/config.h	/^    typedef std::unordered_map<std::string, ConfigVarBase::ptr> ConfigVarMap;$/;"	t	class:rainbow::Config	access:public
rainbow::Config::GetDatas	rainbow/config.h	/^    static ConfigVarMap& GetDatas() {$/;"	f	class:rainbow::Config	access:private	signature:()
rainbow::Config::GetMutex	rainbow/config.h	/^    static RWMutexType& GetMutex() {$/;"	f	class:rainbow::Config	access:private	signature:()
rainbow::Config::LoadFromYaml	rainbow/config.cpp	/^void Config::LoadFromYaml(const YAML::Node& root) {$/;"	f	class:rainbow::Config	signature:(const YAML::Node& root)
rainbow::Config::LoadFromYaml	rainbow/config.h	/^    static void LoadFromYaml(const YAML::Node& root);$/;"	p	class:rainbow::Config	access:public	signature:(const YAML::Node& root)
rainbow::Config::LookUpBase	rainbow/config.cpp	/^ConfigVarBase::ptr Config::LookUpBase(const std::string& name) {$/;"	f	class:rainbow::Config	signature:(const std::string& name)
rainbow::Config::LookUpBase	rainbow/config.h	/^    static ConfigVarBase::ptr LookUpBase(const std::string& name);$/;"	p	class:rainbow::Config	access:public	signature:(const std::string& name)
rainbow::Config::Lookup	rainbow/config.h	/^    static typename ConfigVar<T>::ptr Lookup(const std::string& name) {$/;"	f	class:rainbow::Config	access:public	signature:(const std::string& name)
rainbow::Config::Lookup	rainbow/config.h	/^    static typename ConfigVar<T>::ptr Lookup(const std::string& name,$/;"	f	class:rainbow::Config	access:public	signature:(const std::string& name, const T& default_value, const std::string& description = Ó)
rainbow::Config::RWMutexType	rainbow/config.h	/^    typedef RWMutex RWMutexType;$/;"	t	class:rainbow::Config	access:public
rainbow::Config::Visit	rainbow/config.cpp	/^void Config::Visit(std::function<void(ConfigVarBase::ptr)> cb) {$/;"	f	class:rainbow::Config	signature:(std::function<void(ConfigVarBase::ptr)> cb)
rainbow::Config::Visit	rainbow/config.h	/^    static void Visit(std::function<void(ConfigVarBase::ptr cb)>);$/;"	p	class:rainbow::Config	access:public	signature:(std::function<void(ConfigVarBase::ptr cb)>)
rainbow::ConfigVar	rainbow/config.h	/^class ConfigVar : public ConfigVarBase {$/;"	c	namespace:rainbow	inherits:ConfigVarBase
rainbow::ConfigVar::ConfigVar	rainbow/config.h	/^    ConfigVar(const std::string& name$/;"	f	class:rainbow::ConfigVar	access:public	signature:(const std::string& name , const T& default_value , const std::string& description = Ó)
rainbow::ConfigVar::RWMutexType	rainbow/config.h	/^    typedef RWMutex RWMutexType;$/;"	t	class:rainbow::ConfigVar	access:public
rainbow::ConfigVar::addListener	rainbow/config.h	/^    uint64_t addListener(on_change_cb cb) {$/;"	f	class:rainbow::ConfigVar	access:public	signature:(on_change_cb cb)
rainbow::ConfigVar::clearListener	rainbow/config.h	/^    void clearListener() {$/;"	f	class:rainbow::ConfigVar	access:public	signature:()
rainbow::ConfigVar::delListener	rainbow/config.h	/^    void delListener(uint64_t key) {$/;"	f	class:rainbow::ConfigVar	access:public	signature:(uint64_t key)
rainbow::ConfigVar::getListener	rainbow/config.h	/^    on_change_cb getListener(uint64_t key) {$/;"	f	class:rainbow::ConfigVar	access:public	signature:(uint64_t key)
rainbow::ConfigVar::getValue	rainbow/config.h	/^    const T getValue() { $/;"	f	class:rainbow::ConfigVar	access:public	signature:()
rainbow::ConfigVar::m_cbs	rainbow/config.h	/^    std::map<uint64_t, on_change_cb> m_cbs;$/;"	m	class:rainbow::ConfigVar	access:private
rainbow::ConfigVar::m_mutex	rainbow/config.h	/^    RWMutexType m_mutex;$/;"	m	class:rainbow::ConfigVar	access:private
rainbow::ConfigVar::m_val	rainbow/config.h	/^    T m_val;$/;"	m	class:rainbow::ConfigVar	access:private
rainbow::ConfigVar::on_change_cb	rainbow/config.h	/^    typedef std::function<void (const T& old_value, const T& new_value)> on_change_cb;$/;"	t	class:rainbow::ConfigVar	access:public
rainbow::ConfigVar::ptr	rainbow/config.h	/^    typedef std::shared_ptr<ConfigVar> ptr;$/;"	t	class:rainbow::ConfigVar	access:public
rainbow::ConfigVar::setValue	rainbow/config.h	/^    void setValue(const T& v) { $/;"	f	class:rainbow::ConfigVar	access:public	signature:(const T& v)
rainbow::ConfigVarBase	rainbow/config.h	/^class ConfigVarBase {$/;"	c	namespace:rainbow
rainbow::ConfigVarBase::ConfigVarBase	rainbow/config.h	/^    ConfigVarBase(const std::string& name, const std::string& description = "") $/;"	f	class:rainbow::ConfigVarBase	access:public	signature:(const std::string& name, const std::string& description = Ó)
rainbow::ConfigVarBase::fromString	rainbow/config.h	/^    virtual bool fromString(const std::string& val) = 0;$/;"	p	class:rainbow::ConfigVarBase	access:public	signature:(const std::string& val)
rainbow::ConfigVarBase::getDescription	rainbow/config.h	/^    const std::string& getDescription() const { return m_description; }$/;"	f	class:rainbow::ConfigVarBase	access:public	signature:() const
rainbow::ConfigVarBase::getName	rainbow/config.h	/^    const std::string& getName() const { return m_name; }$/;"	f	class:rainbow::ConfigVarBase	access:public	signature:() const
rainbow::ConfigVarBase::getTypeName	rainbow/config.h	/^    virtual std::string getTypeName() const = 0;$/;"	p	class:rainbow::ConfigVarBase	access:public	signature:() const
rainbow::ConfigVarBase::m_description	rainbow/config.h	/^    std::string m_description;$/;"	m	class:rainbow::ConfigVarBase	access:protected
rainbow::ConfigVarBase::m_name	rainbow/config.h	/^    std::string m_name;$/;"	m	class:rainbow::ConfigVarBase	access:protected
rainbow::ConfigVarBase::ptr	rainbow/config.h	/^    typedef std::shared_ptr<ConfigVarBase> ptr;$/;"	t	class:rainbow::ConfigVarBase	access:public
rainbow::ConfigVarBase::toString	rainbow/config.h	/^    virtual std::string toString() = 0;$/;"	p	class:rainbow::ConfigVarBase	access:public	signature:()
rainbow::ConfigVarBase::~ConfigVarBase	rainbow/config.h	/^    virtual ~ConfigVarBase() {}$/;"	f	class:rainbow::ConfigVarBase	access:public	signature:()
rainbow::DateTimeFormatItem	rainbow/log.cpp	/^class DateTimeFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
rainbow::DateTimeFormatItem::DateTimeFormatItem	rainbow/log.cpp	/^    DateTimeFormatItem(const std::string& format = "%Y-%m-%d %H:%M:%s")$/;"	f	class:rainbow::DateTimeFormatItem	access:public	signature:(const std::string& format = Ó)
rainbow::DateTimeFormatItem::m_format	rainbow/log.cpp	/^    std::string m_format;$/;"	m	class:rainbow::DateTimeFormatItem	file:	access:private
rainbow::ElapseFormatItem	rainbow/log.cpp	/^class ElapseFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
rainbow::ElapseFormatItem::ElapseFormatItem	rainbow/log.cpp	/^    ElapseFormatItem(const std::string str = "") {}$/;"	f	class:rainbow::ElapseFormatItem	access:public	signature:(const std::string str = Ó)
rainbow::Fiber	rainbow/fiber.h	/^class Fiber : public std::enable_shared_from_this<Fiber> {$/;"	c	namespace:rainbow	inherits:std::enable_shared_from_this
rainbow::Fiber::CallerMainFunc	rainbow/fiber.cpp	/^void Fiber::CallerMainFunc() {$/;"	f	class:rainbow::Fiber	signature:()
rainbow::Fiber::CallerMainFunc	rainbow/fiber.h	/^    static void CallerMainFunc();$/;"	p	class:rainbow::Fiber	access:public	signature:()
rainbow::Fiber::EXCEPT	rainbow/fiber.h	/^        EXCEPT$/;"	e	enum:rainbow::Fiber::State
rainbow::Fiber::EXEC	rainbow/fiber.h	/^        EXEC,$/;"	e	enum:rainbow::Fiber::State
rainbow::Fiber::Fiber	rainbow/fiber.cpp	/^Fiber::Fiber() {$/;"	f	class:rainbow::Fiber	signature:()
rainbow::Fiber::Fiber	rainbow/fiber.cpp	/^Fiber::Fiber(std::function<void()> cb, size_t stacksize, bool use_caller) $/;"	f	class:rainbow::Fiber	signature:(std::function<void()> cb, size_t stacksize, bool use_caller)
rainbow::Fiber::Fiber	rainbow/fiber.h	/^    Fiber();$/;"	p	class:rainbow::Fiber	access:private	signature:()
rainbow::Fiber::Fiber	rainbow/fiber.h	/^    Fiber(std::function<void()> cb, size_t stacksize = 0, bool use_caller = false);$/;"	p	class:rainbow::Fiber	access:public	signature:(std::function<void()> cb, size_t stacksize = 0, bool use_caller = false)
rainbow::Fiber::GetFiberId	rainbow/fiber.cpp	/^uint64_t Fiber::GetFiberId() {$/;"	f	class:rainbow::Fiber	signature:()
rainbow::Fiber::GetFiberId	rainbow/fiber.h	/^    static uint64_t GetFiberId();$/;"	p	class:rainbow::Fiber	access:public	signature:()
rainbow::Fiber::GetId	rainbow/fiber.h	/^    uint64_t GetId() const { return m_id; }$/;"	f	class:rainbow::Fiber	access:public	signature:() const
rainbow::Fiber::GetThis	rainbow/fiber.cpp	/^Fiber::ptr Fiber::GetThis() {$/;"	f	class:rainbow::Fiber	signature:()
rainbow::Fiber::GetThis	rainbow/fiber.h	/^    static Fiber::ptr GetThis();$/;"	p	class:rainbow::Fiber	access:public	signature:()
rainbow::Fiber::HOLD	rainbow/fiber.h	/^        HOLD,$/;"	e	enum:rainbow::Fiber::State
rainbow::Fiber::INIT	rainbow/fiber.h	/^        INIT,$/;"	e	enum:rainbow::Fiber::State
rainbow::Fiber::MainFunc	rainbow/fiber.cpp	/^void Fiber::MainFunc() {$/;"	f	class:rainbow::Fiber	signature:()
rainbow::Fiber::MainFunc	rainbow/fiber.h	/^    static void MainFunc();$/;"	p	class:rainbow::Fiber	access:public	signature:()
rainbow::Fiber::READY	rainbow/fiber.h	/^        READY,$/;"	e	enum:rainbow::Fiber::State
rainbow::Fiber::SetThis	rainbow/fiber.cpp	/^void Fiber::SetThis(Fiber* f) {$/;"	f	class:rainbow::Fiber	signature:(Fiber* f)
rainbow::Fiber::SetThis	rainbow/fiber.h	/^    static void SetThis(Fiber* f);$/;"	p	class:rainbow::Fiber	access:public	signature:(Fiber* f)
rainbow::Fiber::State	rainbow/fiber.h	/^    enum State {$/;"	g	class:rainbow::Fiber	access:public
rainbow::Fiber::TERM	rainbow/fiber.h	/^        TERM,$/;"	e	enum:rainbow::Fiber::State
rainbow::Fiber::TotalFibers	rainbow/fiber.cpp	/^uint64_t Fiber::TotalFibers() {$/;"	f	class:rainbow::Fiber	signature:()
rainbow::Fiber::TotalFibers	rainbow/fiber.h	/^    static uint64_t TotalFibers();$/;"	p	class:rainbow::Fiber	access:public	signature:()
rainbow::Fiber::YieldToHold	rainbow/fiber.cpp	/^void Fiber::YieldToHold() {$/;"	f	class:rainbow::Fiber	signature:()
rainbow::Fiber::YieldToHold	rainbow/fiber.h	/^    static void YieldToHold();$/;"	p	class:rainbow::Fiber	access:public	signature:()
rainbow::Fiber::YieldToReady	rainbow/fiber.cpp	/^void Fiber::YieldToReady() {$/;"	f	class:rainbow::Fiber	signature:()
rainbow::Fiber::YieldToReady	rainbow/fiber.h	/^    static void YieldToReady();$/;"	p	class:rainbow::Fiber	access:public	signature:()
rainbow::Fiber::back	rainbow/fiber.cpp	/^void Fiber::back() {$/;"	f	class:rainbow::Fiber	signature:()
rainbow::Fiber::back	rainbow/fiber.h	/^    void back();$/;"	p	class:rainbow::Fiber	access:public	signature:()
rainbow::Fiber::call	rainbow/fiber.cpp	/^void Fiber::call() {$/;"	f	class:rainbow::Fiber	signature:()
rainbow::Fiber::call	rainbow/fiber.h	/^    void call();$/;"	p	class:rainbow::Fiber	access:public	signature:()
rainbow::Fiber::getState	rainbow/fiber.h	/^    uint64_t getState() const { return m_state; }$/;"	f	class:rainbow::Fiber	access:public	signature:() const
rainbow::Fiber::m_cb	rainbow/fiber.h	/^    std::function<void()> m_cb;$/;"	m	class:rainbow::Fiber	access:private
rainbow::Fiber::m_ctx	rainbow/fiber.h	/^    ucontext_t m_ctx;$/;"	m	class:rainbow::Fiber	access:private
rainbow::Fiber::m_id	rainbow/fiber.h	/^    uint64_t m_id = 0;$/;"	m	class:rainbow::Fiber	access:private
rainbow::Fiber::m_stack	rainbow/fiber.h	/^    void* m_stack = nullptr;$/;"	m	class:rainbow::Fiber	access:private
rainbow::Fiber::m_stacksize	rainbow/fiber.h	/^    uint32_t m_stacksize = 0;$/;"	m	class:rainbow::Fiber	access:private
rainbow::Fiber::m_state	rainbow/fiber.h	/^    State m_state = INIT;$/;"	m	class:rainbow::Fiber	access:private
rainbow::Fiber::ptr	rainbow/fiber.h	/^    typedef std::shared_ptr<Fiber> ptr;$/;"	t	class:rainbow::Fiber	access:public
rainbow::Fiber::reset	rainbow/fiber.cpp	/^void Fiber::reset(std::function<void()> cb) {$/;"	f	class:rainbow::Fiber	signature:(std::function<void()> cb)
rainbow::Fiber::reset	rainbow/fiber.h	/^    void reset(std::function<void()> cb);$/;"	p	class:rainbow::Fiber	access:public	signature:(std::function<void()> cb)
rainbow::Fiber::setState	rainbow/fiber.h	/^    void setState(const State state) { m_state = state; }$/;"	f	class:rainbow::Fiber	access:public	signature:(const State state)
rainbow::Fiber::swapIn	rainbow/fiber.cpp	/^void Fiber::swapIn() {$/;"	f	class:rainbow::Fiber	signature:()
rainbow::Fiber::swapIn	rainbow/fiber.h	/^    void swapIn();$/;"	p	class:rainbow::Fiber	access:public	signature:()
rainbow::Fiber::swapOut	rainbow/fiber.cpp	/^void Fiber::swapOut() {$/;"	f	class:rainbow::Fiber	signature:()
rainbow::Fiber::swapOut	rainbow/fiber.h	/^    void swapOut();$/;"	p	class:rainbow::Fiber	access:public	signature:()
rainbow::Fiber::~Fiber	rainbow/fiber.cpp	/^Fiber::~Fiber() {$/;"	f	class:rainbow::Fiber	signature:()
rainbow::Fiber::~Fiber	rainbow/fiber.h	/^    ~Fiber();$/;"	p	class:rainbow::Fiber	access:public	signature:()
rainbow::FiberIdFormatItem	rainbow/log.cpp	/^class FiberIdFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
rainbow::FiberIdFormatItem::FiberIdFormatItem	rainbow/log.cpp	/^    FiberIdFormatItem(const std::string str = "") {}$/;"	f	class:rainbow::FiberIdFormatItem	access:public	signature:(const std::string str = Ó)
rainbow::FileLogAppender	rainbow/log.h	/^class FileLogAppender : public LogAppender {$/;"	c	namespace:rainbow	inherits:LogAppender
rainbow::FileLogAppender::FileLogAppender	rainbow/log.cpp	/^FileLogAppender::FileLogAppender(const std::string& name) : m_filename(name) {$/;"	f	class:rainbow::FileLogAppender	signature:(const std::string& name)
rainbow::FileLogAppender::FileLogAppender	rainbow/log.h	/^    FileLogAppender(const std::string& filename);$/;"	p	class:rainbow::FileLogAppender	access:public	signature:(const std::string& filename)
rainbow::FileLogAppender::log	rainbow/log.cpp	/^void FileLogAppender::log(std::shared_ptr<Logger> logger, LogLevel::Level level,$/;"	f	class:rainbow::FileLogAppender	signature:(std::shared_ptr<Logger> logger, LogLevel::Level level, LogEvent::ptr event)
rainbow::FileLogAppender::m_filename	rainbow/log.h	/^    std::string m_filename;$/;"	m	class:rainbow::FileLogAppender	access:private
rainbow::FileLogAppender::m_filestream	rainbow/log.h	/^    std::ofstream m_filestream;$/;"	m	class:rainbow::FileLogAppender	access:private
rainbow::FileLogAppender::m_lastTime	rainbow/log.h	/^    uint64_t m_lastTime = 0;$/;"	m	class:rainbow::FileLogAppender	access:private
rainbow::FileLogAppender::override	rainbow/log.h	/^                     LogEvent::ptr event) override;$/;"	m	class:rainbow::FileLogAppender	access:public
rainbow::FileLogAppender::override	rainbow/log.h	/^    std::string toYamlString() override;$/;"	m	class:rainbow::FileLogAppender	access:public
rainbow::FileLogAppender::ptr	rainbow/log.h	/^    typedef std::shared_ptr<FileLogAppender> ptr;$/;"	t	class:rainbow::FileLogAppender	access:public
rainbow::FileLogAppender::reopen	rainbow/log.cpp	/^bool FileLogAppender::reopen() {$/;"	f	class:rainbow::FileLogAppender	signature:()
rainbow::FileLogAppender::reopen	rainbow/log.h	/^    bool reopen();$/;"	p	class:rainbow::FileLogAppender	access:public	signature:()
rainbow::FileLogAppender::toYamlString	rainbow/log.cpp	/^std::string FileLogAppender::toYamlString() {$/;"	f	class:rainbow::FileLogAppender	signature:()
rainbow::FileNameFormatItem	rainbow/log.cpp	/^class FileNameFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
rainbow::FileNameFormatItem::FileNameFormatItem	rainbow/log.cpp	/^    FileNameFormatItem(const std::string str = "") {}$/;"	f	class:rainbow::FileNameFormatItem	access:public	signature:(const std::string str = Ó)
rainbow::GetCurrentMS	rainbow/util.cpp	/^uint64_t GetCurrentMS() {$/;"	f	namespace:rainbow	signature:()
rainbow::GetCurrentMS	rainbow/util.h	/^uint64_t GetCurrentMS();$/;"	p	namespace:rainbow	signature:()
rainbow::GetCurrentUS	rainbow/util.cpp	/^uint64_t GetCurrentUS() {$/;"	f	namespace:rainbow	signature:()
rainbow::GetCurrentUS	rainbow/util.h	/^uint64_t GetCurrentUS();$/;"	p	namespace:rainbow	signature:()
rainbow::GetFiberId	rainbow/util.cpp	/^uint32_t GetFiberId() {$/;"	f	namespace:rainbow	signature:()
rainbow::GetFiberId	rainbow/util.h	/^uint32_t GetFiberId();$/;"	p	namespace:rainbow	signature:()
rainbow::GetThreadId	rainbow/util.cpp	/^pid_t GetThreadId() {$/;"	f	namespace:rainbow	signature:()
rainbow::GetThreadId	rainbow/util.h	/^pid_t GetThreadId();$/;"	p	namespace:rainbow	signature:()
rainbow::IOManager	rainbow/iomanager.h	/^class IOManager : public Scheduler, public TimerManager{$/;"	c	namespace:rainbow	inherits:Scheduler,TimerManager
rainbow::IOManager::Event	rainbow/iomanager.h	/^    enum Event {$/;"	g	class:rainbow::IOManager	access:public
rainbow::IOManager::FdContext	rainbow/iomanager.h	/^    struct FdContext {$/;"	s	class:rainbow::IOManager	access:private
rainbow::IOManager::FdContext::EventContext	rainbow/iomanager.h	/^        struct EventContext {$/;"	s	struct:rainbow::IOManager::FdContext	access:public
rainbow::IOManager::FdContext::EventContext::cb	rainbow/iomanager.h	/^            std::function<void()> cb;       \/\/ äºä»¶çåè°å½æ°$/;"	m	struct:rainbow::IOManager::FdContext::EventContext	access:public
rainbow::IOManager::FdContext::EventContext::fiber	rainbow/iomanager.h	/^            std::shared_ptr<Fiber> fiber;   \/\/ äºä»¶åç¨$/;"	m	struct:rainbow::IOManager::FdContext::EventContext	access:public
rainbow::IOManager::FdContext::EventContext::scheduler	rainbow/iomanager.h	/^            Scheduler* scheduler = nullptr;           \/\/ äºä»¶æ§è¡ç scheduler$/;"	m	struct:rainbow::IOManager::FdContext::EventContext	access:public
rainbow::IOManager::FdContext::MutexType	rainbow/iomanager.h	/^        typedef Mutex MutexType;$/;"	t	struct:rainbow::IOManager::FdContext	access:public
rainbow::IOManager::FdContext::events	rainbow/iomanager.h	/^        Event events = NONE;    \/\/ å·²ç»æ³¨åçäºä»¶$/;"	m	struct:rainbow::IOManager::FdContext	access:public
rainbow::IOManager::FdContext::fd	rainbow/iomanager.h	/^        int fd = 0;             \/\/ äºä»¶å³èçå¥æ$/;"	m	struct:rainbow::IOManager::FdContext	access:public
rainbow::IOManager::FdContext::getContext	rainbow/iomanager.cpp	/^IOManager::FdContext::EventContext& IOManager::FdContext::getContext(IOManager::Event event) {$/;"	f	class:rainbow::IOManager::FdContext	signature:(IOManager::Event event)
rainbow::IOManager::FdContext::getContext	rainbow/iomanager.h	/^        EventContext& getContext(Event event);$/;"	p	struct:rainbow::IOManager::FdContext	access:public	signature:(Event event)
rainbow::IOManager::FdContext::mutex	rainbow/iomanager.h	/^        MutexType mutex;$/;"	m	struct:rainbow::IOManager::FdContext	access:public
rainbow::IOManager::FdContext::read	rainbow/iomanager.h	/^        EventContext read;      \/\/ è¯»äºä»¶$/;"	m	struct:rainbow::IOManager::FdContext	access:public
rainbow::IOManager::FdContext::resetContext	rainbow/iomanager.cpp	/^void IOManager::FdContext::resetContext(EventContext& ctx) {$/;"	f	class:rainbow::IOManager::FdContext	signature:(EventContext& ctx)
rainbow::IOManager::FdContext::resetContext	rainbow/iomanager.h	/^        void resetContext(EventContext& ctx);$/;"	p	struct:rainbow::IOManager::FdContext	access:public	signature:(EventContext& ctx)
rainbow::IOManager::FdContext::triggerEvent	rainbow/iomanager.cpp	/^void IOManager::FdContext::triggerEvent(IOManager::Event event) {$/;"	f	class:rainbow::IOManager::FdContext	signature:(IOManager::Event event)
rainbow::IOManager::FdContext::triggerEvent	rainbow/iomanager.h	/^        void triggerEvent(Event event);$/;"	p	struct:rainbow::IOManager::FdContext	access:public	signature:(Event event)
rainbow::IOManager::FdContext::write	rainbow/iomanager.h	/^        EventContext write;     \/\/ åäºä»¶$/;"	m	struct:rainbow::IOManager::FdContext	access:public
rainbow::IOManager::GetThis	rainbow/iomanager.cpp	/^IOManager* IOManager::GetThis() {$/;"	f	class:rainbow::IOManager	signature:()
rainbow::IOManager::GetThis	rainbow/iomanager.h	/^    static IOManager* GetThis();$/;"	p	class:rainbow::IOManager	access:public	signature:()
rainbow::IOManager::IOManager	rainbow/iomanager.cpp	/^IOManager::IOManager(size_t threads, bool use_caller, const std::string& name)$/;"	f	class:rainbow::IOManager	signature:(size_t threads, bool use_caller, const std::string& name)
rainbow::IOManager::IOManager	rainbow/iomanager.h	/^    IOManager(size_t threads = 1, bool use_caller = true, const std::string& name = "");$/;"	p	class:rainbow::IOManager	access:public	signature:(size_t threads = 1, bool use_caller = true, const std::string& name = Ó)
rainbow::IOManager::NONE	rainbow/iomanager.h	/^        NONE    = 0x0,$/;"	e	enum:rainbow::IOManager::Event
rainbow::IOManager::READ	rainbow/iomanager.h	/^        READ    = 0x1,  \/\/ EPOLLIN$/;"	e	enum:rainbow::IOManager::Event
rainbow::IOManager::RWMutexType	rainbow/iomanager.h	/^    typedef RWMutex RWMutexType;$/;"	t	class:rainbow::IOManager	access:public
rainbow::IOManager::WRITE	rainbow/iomanager.h	/^        WRITE   = 0x4,  \/\/ EPOLLOUT$/;"	e	enum:rainbow::IOManager::Event
rainbow::IOManager::addEvent	rainbow/iomanager.cpp	/^int IOManager::addEvent(int fd, Event event, std::function<void()> cb) {$/;"	f	class:rainbow::IOManager	signature:(int fd, Event event, std::function<void()> cb)
rainbow::IOManager::addEvent	rainbow/iomanager.h	/^    int addEvent(int fd, Event event, std::function<void()> cb = nullptr);$/;"	p	class:rainbow::IOManager	access:public	signature:(int fd, Event event, std::function<void()> cb = nullptr)
rainbow::IOManager::cancelAll	rainbow/iomanager.cpp	/^bool IOManager::cancelAll(int fd) {$/;"	f	class:rainbow::IOManager	signature:(int fd)
rainbow::IOManager::cancelAll	rainbow/iomanager.h	/^    bool cancelAll(int fd);$/;"	p	class:rainbow::IOManager	access:public	signature:(int fd)
rainbow::IOManager::cancelEvent	rainbow/iomanager.cpp	/^bool IOManager::cancelEvent(int fd, Event event) {$/;"	f	class:rainbow::IOManager	signature:(int fd, Event event)
rainbow::IOManager::cancelEvent	rainbow/iomanager.h	/^    bool cancelEvent(int fd, Event event);$/;"	p	class:rainbow::IOManager	access:public	signature:(int fd, Event event)
rainbow::IOManager::contextResize	rainbow/iomanager.cpp	/^void IOManager::contextResize(size_t size) {$/;"	f	class:rainbow::IOManager	signature:(size_t size)
rainbow::IOManager::contextResize	rainbow/iomanager.h	/^    void contextResize(size_t size);$/;"	p	class:rainbow::IOManager	access:protected	signature:(size_t size)
rainbow::IOManager::delEvent	rainbow/iomanager.cpp	/^bool IOManager::delEvent(int fd, Event event) {$/;"	f	class:rainbow::IOManager	signature:(int fd, Event event)
rainbow::IOManager::delEvent	rainbow/iomanager.h	/^    bool delEvent(int fd, Event event);$/;"	p	class:rainbow::IOManager	access:public	signature:(int fd, Event event)
rainbow::IOManager::idle	rainbow/iomanager.cpp	/^void IOManager::idle() {$/;"	f	class:rainbow::IOManager	signature:()
rainbow::IOManager::m_epfd	rainbow/iomanager.h	/^    int m_epfd = 0;$/;"	m	class:rainbow::IOManager	access:private
rainbow::IOManager::m_fdContexts	rainbow/iomanager.h	/^    std::vector<FdContext*> m_fdContexts;$/;"	m	class:rainbow::IOManager	access:private
rainbow::IOManager::m_mutex	rainbow/iomanager.h	/^    RWMutexType m_mutex;$/;"	m	class:rainbow::IOManager	access:private
rainbow::IOManager::m_pendingEventCount	rainbow/iomanager.h	/^    std::atomic<size_t> m_pendingEventCount = {0};$/;"	m	class:rainbow::IOManager	access:private
rainbow::IOManager::m_tickleFds	rainbow/iomanager.h	/^    int m_tickleFds[2];$/;"	m	class:rainbow::IOManager	access:private
rainbow::IOManager::onTimerInsertedAtFront	rainbow/iomanager.cpp	/^void IOManager::onTimerInsertedAtFront() {$/;"	f	class:rainbow::IOManager	signature:()
rainbow::IOManager::override	rainbow/iomanager.h	/^    bool stopping() override;$/;"	m	class:rainbow::IOManager	access:protected
rainbow::IOManager::override	rainbow/iomanager.h	/^    void idle() override;$/;"	m	class:rainbow::IOManager	access:protected
rainbow::IOManager::override	rainbow/iomanager.h	/^    void onTimerInsertedAtFront() override;$/;"	m	class:rainbow::IOManager	access:protected
rainbow::IOManager::override	rainbow/iomanager.h	/^    void tickle() override;$/;"	m	class:rainbow::IOManager	access:protected
rainbow::IOManager::ptr	rainbow/iomanager.h	/^    typedef std::shared_ptr<IOManager> ptr;$/;"	t	class:rainbow::IOManager	access:public
rainbow::IOManager::stopping	rainbow/iomanager.cpp	/^bool IOManager::stopping() {$/;"	f	class:rainbow::IOManager	signature:()
rainbow::IOManager::tickle	rainbow/iomanager.cpp	/^void IOManager::tickle() {$/;"	f	class:rainbow::IOManager	signature:()
rainbow::IOManager::~IOManager	rainbow/iomanager.cpp	/^IOManager::~IOManager() {$/;"	f	class:rainbow::IOManager	signature:()
rainbow::IOManager::~IOManager	rainbow/iomanager.h	/^    ~IOManager();$/;"	p	class:rainbow::IOManager	access:public	signature:()
rainbow::LevelFormatItem	rainbow/log.cpp	/^class LevelFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
rainbow::LevelFormatItem::LevelFormatItem	rainbow/log.cpp	/^    LevelFormatItem(const std::string str = "") {}$/;"	f	class:rainbow::LevelFormatItem	access:public	signature:(const std::string str = Ó)
rainbow::LexicalCast	rainbow/config.h	/^class LexicalCast {$/;"	c	namespace:rainbow
rainbow::LexicalCast	rainbow/config.h	/^class LexicalCast<std::list<T>, std::string> {$/;"	c	namespace:rainbow
rainbow::LexicalCast	rainbow/config.h	/^class LexicalCast<std::map<std::string, T>, std::string> {$/;"	c	namespace:rainbow
rainbow::LexicalCast	rainbow/config.h	/^class LexicalCast<std::set<T>, std::string> {$/;"	c	namespace:rainbow
rainbow::LexicalCast	rainbow/config.h	/^class LexicalCast<std::string, std::list<T> > {$/;"	c	namespace:rainbow
rainbow::LexicalCast	rainbow/config.h	/^class LexicalCast<std::string, std::map<std::string, T> > {$/;"	c	namespace:rainbow
rainbow::LexicalCast	rainbow/config.h	/^class LexicalCast<std::string, std::set<T> > {$/;"	c	namespace:rainbow
rainbow::LexicalCast	rainbow/config.h	/^class LexicalCast<std::string, std::unordered_map<std::string, T> > {$/;"	c	namespace:rainbow
rainbow::LexicalCast	rainbow/config.h	/^class LexicalCast<std::string, std::unordered_set<T> > {$/;"	c	namespace:rainbow
rainbow::LexicalCast	rainbow/config.h	/^class LexicalCast<std::string, std::vector<T> > {$/;"	c	namespace:rainbow
rainbow::LexicalCast	rainbow/config.h	/^class LexicalCast<std::unordered_map<std::string, T>, std::string> {$/;"	c	namespace:rainbow
rainbow::LexicalCast	rainbow/config.h	/^class LexicalCast<std::unordered_set<T>, std::string> {$/;"	c	namespace:rainbow
rainbow::LexicalCast	rainbow/config.h	/^class LexicalCast<std::vector<T>, std::string> {$/;"	c	namespace:rainbow
rainbow::LexicalCast	rainbow/log.cpp	/^class LexicalCast<std::set<LogDefine>, std::string> {$/;"	c	namespace:rainbow	file:
rainbow::LexicalCast	rainbow/log.cpp	/^class LexicalCast<std::string, std::set<LogDefine> > {$/;"	c	namespace:rainbow	file:
rainbow::LexicalCast	tests/test_config.cpp	/^class LexicalCast<Person, std::string> {$/;"	c	namespace:rainbow	file:
rainbow::LexicalCast	tests/test_config.cpp	/^class LexicalCast<std::string, Person> {$/;"	c	namespace:rainbow	file:
rainbow::LexicalCast::operator ()	rainbow/config.h	/^    T operator()(const F& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const F& v)
rainbow::LexicalCast::operator ()	rainbow/config.h	/^    std::list<T> operator()(const std::string& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::string& v)
rainbow::LexicalCast::operator ()	rainbow/config.h	/^    std::map<std::string, T> operator()(const std::string& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::string& v)
rainbow::LexicalCast::operator ()	rainbow/config.h	/^    std::set<T> operator()(const std::string& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::string& v)
rainbow::LexicalCast::operator ()	rainbow/config.h	/^    std::string operator()(const std::list<T>& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::list<T>& v)
rainbow::LexicalCast::operator ()	rainbow/config.h	/^    std::string operator()(const std::map<std::string, T>& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::map<std::string, T>& v)
rainbow::LexicalCast::operator ()	rainbow/config.h	/^    std::string operator()(const std::set<T>& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::set<T>& v)
rainbow::LexicalCast::operator ()	rainbow/config.h	/^    std::string operator()(const std::unordered_map<std::string, T>& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::unordered_map<std::string, T>& v)
rainbow::LexicalCast::operator ()	rainbow/config.h	/^    std::string operator()(const std::unordered_set<T>& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::unordered_set<T>& v)
rainbow::LexicalCast::operator ()	rainbow/config.h	/^    std::string operator()(const std::vector<T>& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::vector<T>& v)
rainbow::LexicalCast::operator ()	rainbow/config.h	/^    std::unordered_map<std::string, T> operator()(const std::string& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::string& v)
rainbow::LexicalCast::operator ()	rainbow/config.h	/^    std::unordered_set<T> operator()(const std::string& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::string& v)
rainbow::LexicalCast::operator ()	rainbow/config.h	/^    std::vector<T> operator()(const std::string& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::string& v)
rainbow::LexicalCast::operator ()	rainbow/log.cpp	/^    std::set<LogDefine> operator()(const std::string& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::string& v)
rainbow::LexicalCast::operator ()	rainbow/log.cpp	/^    std::string operator()(const std::set<LogDefine>& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::set<LogDefine>& v)
rainbow::LexicalCast::operator ()	tests/test_config.cpp	/^    Person operator()(const std::string& v) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const std::string& v)
rainbow::LexicalCast::operator ()	tests/test_config.cpp	/^    std::string operator()(const Person& p) {$/;"	f	class:rainbow::LexicalCast	access:public	signature:(const Person& p)
rainbow::LineFormatItem	rainbow/log.cpp	/^class LineFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
rainbow::LineFormatItem::LineFormatItem	rainbow/log.cpp	/^    LineFormatItem(const std::string str = "") {}$/;"	f	class:rainbow::LineFormatItem	access:public	signature:(const std::string str = Ó)
rainbow::ListAllMember	rainbow/config.cpp	/^static void ListAllMember(const std::string& prefix, $/;"	f	namespace:rainbow	signature:(const std::string& prefix, const YAML::Node& node, std::list<std::pair<std::string, const YAML::Node> >& output)
rainbow::LogAppender	rainbow/log.h	/^class LogAppender {$/;"	c	namespace:rainbow
rainbow::LogAppender::LogAppender	rainbow/log.cpp	/^LogAppender::LogAppender() {$/;"	f	class:rainbow::LogAppender	signature:()
rainbow::LogAppender::LogAppender	rainbow/log.h	/^    LogAppender();$/;"	p	class:rainbow::LogAppender	access:public	signature:()
rainbow::LogAppender::MutexType	rainbow/log.h	/^    typedef Spinlock MutexType;$/;"	t	class:rainbow::LogAppender	access:public
rainbow::LogAppender::getFormatter	rainbow/log.cpp	/^LogFormatter::ptr LogAppender::getFormatter() {$/;"	f	class:rainbow::LogAppender	signature:()
rainbow::LogAppender::getFormatter	rainbow/log.h	/^    LogFormatter::ptr getFormatter(); $/;"	p	class:rainbow::LogAppender	access:public	signature:()
rainbow::LogAppender::getLevel	rainbow/log.h	/^    LogLevel::Level getLevel() const { return m_level; }$/;"	f	class:rainbow::LogAppender	access:public	signature:() const
rainbow::LogAppender::log	rainbow/log.h	/^    virtual void log(std::shared_ptr<Logger> logger, LogLevel::Level level,$/;"	p	class:rainbow::LogAppender	access:public	signature:(std::shared_ptr<Logger> logger, LogLevel::Level level, LogEvent::ptr event)
rainbow::LogAppender::m_formatter	rainbow/log.h	/^    LogFormatter::ptr m_formatter;$/;"	m	class:rainbow::LogAppender	access:protected
rainbow::LogAppender::m_hasFormatter	rainbow/log.h	/^    bool m_hasFormatter = false;$/;"	m	class:rainbow::LogAppender	access:protected
rainbow::LogAppender::m_level	rainbow/log.h	/^    LogLevel::Level m_level = LogLevel::DEBUG;$/;"	m	class:rainbow::LogAppender	access:protected
rainbow::LogAppender::m_mutex	rainbow/log.h	/^    MutexType m_mutex;$/;"	m	class:rainbow::LogAppender	access:protected
rainbow::LogAppender::ptr	rainbow/log.h	/^    typedef std::shared_ptr<LogAppender> ptr;$/;"	t	class:rainbow::LogAppender	access:public
rainbow::LogAppender::setFormatter	rainbow/log.cpp	/^void LogAppender::setFormatter(LogFormatter::ptr val) {$/;"	f	class:rainbow::LogAppender	signature:(LogFormatter::ptr val)
rainbow::LogAppender::setFormatter	rainbow/log.h	/^    void setFormatter(LogFormatter::ptr val);$/;"	p	class:rainbow::LogAppender	access:public	signature:(LogFormatter::ptr val)
rainbow::LogAppender::setLevel	rainbow/log.cpp	/^void LogAppender::setLevel(const LogLevel::Level& level) {$/;"	f	class:rainbow::LogAppender	signature:(const LogLevel::Level& level)
rainbow::LogAppender::setLevel	rainbow/log.h	/^    void setLevel(const LogLevel::Level& level);$/;"	p	class:rainbow::LogAppender	access:public	signature:(const LogLevel::Level& level)
rainbow::LogAppender::toYamlString	rainbow/log.h	/^    virtual std::string toYamlString() = 0;$/;"	p	class:rainbow::LogAppender	access:public	signature:()
rainbow::LogAppender::~LogAppender	rainbow/log.h	/^    virtual ~LogAppender() {}$/;"	f	class:rainbow::LogAppender	access:public	signature:()
rainbow::LogAppenderDefine	rainbow/log.cpp	/^struct LogAppenderDefine {$/;"	s	namespace:rainbow	file:
rainbow::LogAppenderDefine::file	rainbow/log.cpp	/^    std::string file;$/;"	m	struct:rainbow::LogAppenderDefine	file:	access:public
rainbow::LogAppenderDefine::formatter	rainbow/log.cpp	/^    std::string formatter;$/;"	m	struct:rainbow::LogAppenderDefine	file:	access:public
rainbow::LogAppenderDefine::level	rainbow/log.cpp	/^    LogLevel::Level level = LogLevel::UNKNOW;$/;"	m	struct:rainbow::LogAppenderDefine	file:	access:public
rainbow::LogAppenderDefine::operator ==	rainbow/log.cpp	/^    bool operator==(const LogAppenderDefine& oth) const {$/;"	f	struct:rainbow::LogAppenderDefine	access:public	signature:(const LogAppenderDefine& oth) const
rainbow::LogAppenderDefine::type	rainbow/log.cpp	/^    int type = 0; \/\/ 1 File, 2 Stdout$/;"	m	struct:rainbow::LogAppenderDefine	file:	access:public
rainbow::LogDefine	rainbow/log.cpp	/^struct LogDefine {$/;"	s	namespace:rainbow	file:
rainbow::LogDefine::appenders	rainbow/log.cpp	/^    std::vector<LogAppenderDefine> appenders;$/;"	m	struct:rainbow::LogDefine	file:	access:public
rainbow::LogDefine::formatter	rainbow/log.cpp	/^    std::string formatter;$/;"	m	struct:rainbow::LogDefine	file:	access:public
rainbow::LogDefine::level	rainbow/log.cpp	/^    LogLevel::Level level = LogLevel::UNKNOW;$/;"	m	struct:rainbow::LogDefine	file:	access:public
rainbow::LogDefine::name	rainbow/log.cpp	/^    std::string name;$/;"	m	struct:rainbow::LogDefine	file:	access:public
rainbow::LogDefine::operator <	rainbow/log.cpp	/^    bool operator<(const LogDefine& oth) const {$/;"	f	struct:rainbow::LogDefine	access:public	signature:(const LogDefine& oth) const
rainbow::LogDefine::operator ==	rainbow/log.cpp	/^    bool operator==(const LogDefine& oth) const {$/;"	f	struct:rainbow::LogDefine	access:public	signature:(const LogDefine& oth) const
rainbow::LogEvent	rainbow/log.h	/^class LogEvent {$/;"	c	namespace:rainbow
rainbow::LogEvent::LogEvent	rainbow/log.cpp	/^LogEvent::LogEvent(const std::shared_ptr<Logger> logger, LogLevel::Level level, const char* file, $/;"	f	class:rainbow::LogEvent	signature:(const std::shared_ptr<Logger> logger, LogLevel::Level level, const char* file, int32_t line, uint32_t elapse, uint32_t thread_id, uint32_t fiber_id, uint64_t time, const std::string& threadName)
rainbow::LogEvent::LogEvent	rainbow/log.h	/^    LogEvent(std::shared_ptr<Logger> logger, LogLevel::Level level, const char* file, $/;"	p	class:rainbow::LogEvent	access:public	signature:(std::shared_ptr<Logger> logger, LogLevel::Level level, const char* file, int32_t m_line, uint32_t elapse, uint32_t thread_id, uint32_t fiber_id, uint64_t time, const std::string& thread_name)
rainbow::LogEvent::format	rainbow/log.cpp	/^void LogEvent::format(const char* fmt, ...) {$/;"	f	class:rainbow::LogEvent	signature:(const char* fmt, ...)
rainbow::LogEvent::format	rainbow/log.cpp	/^void LogEvent::format(const char* fmt, va_list al) {$/;"	f	class:rainbow::LogEvent	signature:(const char* fmt, va_list al)
rainbow::LogEvent::format	rainbow/log.h	/^    void format(const char* fmt, ...);$/;"	p	class:rainbow::LogEvent	access:public	signature:(const char* fmt, ...)
rainbow::LogEvent::format	rainbow/log.h	/^    void format(const char* fmt, va_list al);$/;"	p	class:rainbow::LogEvent	access:public	signature:(const char* fmt, va_list al)
rainbow::LogEvent::getContent	rainbow/log.h	/^    std::string getContent() const { return m_ss.str(); }$/;"	f	class:rainbow::LogEvent	access:public	signature:() const
rainbow::LogEvent::getElapse	rainbow/log.h	/^    uint32_t getElapse() const { return m_elapse; }$/;"	f	class:rainbow::LogEvent	access:public	signature:() const
rainbow::LogEvent::getFiberId	rainbow/log.h	/^    uint32_t getFiberId() const { return m_fiberId; }$/;"	f	class:rainbow::LogEvent	access:public	signature:() const
rainbow::LogEvent::getFileName	rainbow/log.h	/^    const char* getFileName() const { return m_file; }$/;"	f	class:rainbow::LogEvent	access:public	signature:() const
rainbow::LogEvent::getLevel	rainbow/log.h	/^    LogLevel::Level getLevel() const { return m_level; }$/;"	f	class:rainbow::LogEvent	access:public	signature:() const
rainbow::LogEvent::getLine	rainbow/log.h	/^    int32_t getLine() const { return m_line; }$/;"	f	class:rainbow::LogEvent	access:public	signature:() const
rainbow::LogEvent::getLogger	rainbow/log.h	/^    std::shared_ptr<Logger> getLogger() const {  return m_logger; }$/;"	f	class:rainbow::LogEvent	access:public	signature:() const
rainbow::LogEvent::getSS	rainbow/log.h	/^    std::stringstream& getSS() { return m_ss; }$/;"	f	class:rainbow::LogEvent	access:public	signature:()
rainbow::LogEvent::getThreadId	rainbow/log.h	/^    uint32_t getThreadId() const { return m_threadId; }$/;"	f	class:rainbow::LogEvent	access:public	signature:() const
rainbow::LogEvent::getThreadName	rainbow/log.h	/^    const std::string& getThreadName() { return m_threadName; }$/;"	f	class:rainbow::LogEvent	access:public	signature:()
rainbow::LogEvent::getTime	rainbow/log.h	/^    uint32_t getTime() const { return m_time; }$/;"	f	class:rainbow::LogEvent	access:public	signature:() const
rainbow::LogEvent::m_elapse	rainbow/log.h	/^    uint32_t m_elapse = 0;         \/\/ ç¨åºå¯å¨å¼å§å°ç°å¨çæ¯«ç§æ°$/;"	m	class:rainbow::LogEvent	access:private
rainbow::LogEvent::m_fiberId	rainbow/log.h	/^    uint32_t m_fiberId = 0;        \/\/ åç¨id$/;"	m	class:rainbow::LogEvent	access:private
rainbow::LogEvent::m_file	rainbow/log.h	/^    const char* m_file = nullptr;  \/\/ æä»¶å$/;"	m	class:rainbow::LogEvent	access:private
rainbow::LogEvent::m_level	rainbow/log.h	/^    LogLevel::Level m_level;            \/\/ è¯¥æ¥å¿äºä»¶ççº§å«$/;"	m	class:rainbow::LogEvent	access:private
rainbow::LogEvent::m_line	rainbow/log.h	/^    int32_t m_line = 0;            \/\/ è¡å·$/;"	m	class:rainbow::LogEvent	access:private
rainbow::LogEvent::m_logger	rainbow/log.h	/^    std::shared_ptr<Logger> m_logger;   \/\/ æå Logger ç±»çæé$/;"	m	class:rainbow::LogEvent	access:private
rainbow::LogEvent::m_ss	rainbow/log.h	/^    std::stringstream m_ss;             \/\/ æ¥å¿æµ$/;"	m	class:rainbow::LogEvent	access:private
rainbow::LogEvent::m_threadId	rainbow/log.h	/^    uint32_t m_threadId = 0;       \/\/ çº¿ç¨id$/;"	m	class:rainbow::LogEvent	access:private
rainbow::LogEvent::m_threadName	rainbow/log.h	/^    std::string m_threadName;$/;"	m	class:rainbow::LogEvent	access:private
rainbow::LogEvent::m_time	rainbow/log.h	/^    uint64_t m_time;               \/\/ æ¶é´æ³$/;"	m	class:rainbow::LogEvent	access:private
rainbow::LogEvent::ptr	rainbow/log.h	/^    typedef std::shared_ptr<LogEvent> ptr;$/;"	t	class:rainbow::LogEvent	access:public
rainbow::LogEvent::~LogEvent	rainbow/log.h	/^    ~LogEvent() {}$/;"	f	class:rainbow::LogEvent	access:public	signature:()
rainbow::LogEventWrap	rainbow/log.h	/^class LogEventWrap {$/;"	c	namespace:rainbow
rainbow::LogEventWrap::LogEventWrap	rainbow/log.cpp	/^LogEventWrap::LogEventWrap(LogEvent::ptr e) : m_event(e) {$/;"	f	class:rainbow::LogEventWrap	signature:(LogEvent::ptr e)
rainbow::LogEventWrap::LogEventWrap	rainbow/log.h	/^    LogEventWrap(LogEvent::ptr e);$/;"	p	class:rainbow::LogEventWrap	access:public	signature:(LogEvent::ptr e)
rainbow::LogEventWrap::getEvent	rainbow/log.h	/^    LogEvent::ptr getEvent() const { return m_event; }$/;"	f	class:rainbow::LogEventWrap	access:public	signature:() const
rainbow::LogEventWrap::getSS	rainbow/log.cpp	/^std::stringstream& LogEventWrap::getSS() {$/;"	f	class:rainbow::LogEventWrap	signature:()
rainbow::LogEventWrap::getSS	rainbow/log.h	/^    std::stringstream& getSS();$/;"	p	class:rainbow::LogEventWrap	access:public	signature:()
rainbow::LogEventWrap::m_event	rainbow/log.h	/^    LogEvent::ptr m_event;$/;"	m	class:rainbow::LogEventWrap	access:private
rainbow::LogEventWrap::~LogEventWrap	rainbow/log.cpp	/^LogEventWrap::~LogEventWrap() {$/;"	f	class:rainbow::LogEventWrap	signature:()
rainbow::LogEventWrap::~LogEventWrap	rainbow/log.h	/^    ~LogEventWrap();$/;"	p	class:rainbow::LogEventWrap	access:public	signature:()
rainbow::LogFormatter	rainbow/log.h	/^class LogFormatter {$/;"	c	namespace:rainbow
rainbow::LogFormatter::FormatItem	rainbow/log.h	/^    class FormatItem {$/;"	c	class:rainbow::LogFormatter	access:public
rainbow::LogFormatter::FormatItem::FormatItem	rainbow/log.h	/^        FormatItem(const std::string& fmt = ""){};$/;"	f	class:rainbow::LogFormatter::FormatItem	access:public	signature:(const std::string& fmt = Ó)
rainbow::LogFormatter::FormatItem::format	rainbow/log.cpp	/^void LogFormatter::FormatItem::format(std::ostream& os,$/;"	f	class:rainbow::LogFormatter::FormatItem	signature:(std::ostream& os, std::shared_ptr<Logger> logger, LogLevel::Level level, LogEvent::ptr event)
rainbow::LogFormatter::FormatItem::format	rainbow/log.h	/^        virtual void format(std::ostream& os, std::shared_ptr<Logger> logger,$/;"	p	class:rainbow::LogFormatter::FormatItem	access:public	signature:(std::ostream& os, std::shared_ptr<Logger> logger, LogLevel::Level level, LogEvent::ptr event)
rainbow::LogFormatter::FormatItem::ptr	rainbow/log.h	/^        typedef std::shared_ptr<FormatItem> ptr;$/;"	t	class:rainbow::LogFormatter::FormatItem	access:public
rainbow::LogFormatter::FormatItem::~FormatItem	rainbow/log.h	/^        virtual ~FormatItem() {}$/;"	f	class:rainbow::LogFormatter::FormatItem	access:public	signature:()
rainbow::LogFormatter::LogFormatter	rainbow/log.cpp	/^LogFormatter::LogFormatter(const std::string& pattern) : m_pattern(pattern) {$/;"	f	class:rainbow::LogFormatter	signature:(const std::string& pattern)
rainbow::LogFormatter::LogFormatter	rainbow/log.h	/^    LogFormatter(const std::string& pattern);$/;"	p	class:rainbow::LogFormatter	access:public	signature:(const std::string& pattern)
rainbow::LogFormatter::format	rainbow/log.cpp	/^std::string LogFormatter::format(std::shared_ptr<Logger> logger,$/;"	f	class:rainbow::LogFormatter	signature:(std::shared_ptr<Logger> logger, LogLevel::Level level, LogEvent::ptr event)
rainbow::LogFormatter::format	rainbow/log.h	/^    std::ostream& format(std::ostream& ofs, std::shared_ptr<Logger> ptr, LogLevel::Level level, LogEvent::ptr event);$/;"	p	class:rainbow::LogFormatter	access:public	signature:(std::ostream& ofs, std::shared_ptr<Logger> ptr, LogLevel::Level level, LogEvent::ptr event)
rainbow::LogFormatter::format	rainbow/log.h	/^    std::string format(std::shared_ptr<Logger> ptr, LogLevel::Level level,$/;"	p	class:rainbow::LogFormatter	access:public	signature:(std::shared_ptr<Logger> ptr, LogLevel::Level level, LogEvent::ptr event)
rainbow::LogFormatter::getPattern	rainbow/log.h	/^    const std::string getPattern() const { return m_pattern; }$/;"	f	class:rainbow::LogFormatter	access:public	signature:() const
rainbow::LogFormatter::init	rainbow/log.cpp	/^void LogFormatter::init() {$/;"	f	class:rainbow::LogFormatter	signature:()
rainbow::LogFormatter::init	rainbow/log.h	/^    void init();$/;"	p	class:rainbow::LogFormatter	access:public	signature:()
rainbow::LogFormatter::isError	rainbow/log.h	/^    bool isError() const {$/;"	f	class:rainbow::LogFormatter	access:public	signature:() const
rainbow::LogFormatter::m_error	rainbow/log.h	/^    bool m_error = false;$/;"	m	class:rainbow::LogFormatter	access:private
rainbow::LogFormatter::m_items	rainbow/log.h	/^    std::vector<FormatItem::ptr> m_items;$/;"	m	class:rainbow::LogFormatter	access:private
rainbow::LogFormatter::m_pattern	rainbow/log.h	/^    std::string m_pattern;$/;"	m	class:rainbow::LogFormatter	access:private
rainbow::LogFormatter::ptr	rainbow/log.h	/^    typedef std::shared_ptr<LogFormatter> ptr;$/;"	t	class:rainbow::LogFormatter	access:public
rainbow::LogIniter	rainbow/log.cpp	/^struct LogIniter {$/;"	s	namespace:rainbow	file:
rainbow::LogIniter::LogIniter	rainbow/log.cpp	/^    LogIniter() {$/;"	f	struct:rainbow::LogIniter	access:public	signature:()
rainbow::LogLevel	rainbow/log.h	/^class LogLevel {$/;"	c	namespace:rainbow
rainbow::LogLevel::DEBUG	rainbow/log.h	/^        DEBUG = 1,$/;"	e	enum:rainbow::LogLevel::Level
rainbow::LogLevel::ERROR	rainbow/log.h	/^        ERROR = 4,$/;"	e	enum:rainbow::LogLevel::Level
rainbow::LogLevel::FATAL	rainbow/log.h	/^        FATAL = 5$/;"	e	enum:rainbow::LogLevel::Level
rainbow::LogLevel::FromString	rainbow/log.cpp	/^LogLevel::Level LogLevel::FromString(const std::string& str) {$/;"	f	class:rainbow::LogLevel	signature:(const std::string& str)
rainbow::LogLevel::FromString	rainbow/log.h	/^    static LogLevel::Level FromString(const std::string& str);$/;"	p	class:rainbow::LogLevel	access:public	signature:(const std::string& str)
rainbow::LogLevel::INFO	rainbow/log.h	/^        INFO = 2,$/;"	e	enum:rainbow::LogLevel::Level
rainbow::LogLevel::Level	rainbow/log.h	/^    enum Level {$/;"	g	class:rainbow::LogLevel	access:public
rainbow::LogLevel::ToString	rainbow/log.cpp	/^const char* LogLevel::ToString(LogLevel::Level level) {$/;"	f	class:rainbow::LogLevel	signature:(LogLevel::Level level)
rainbow::LogLevel::ToString	rainbow/log.h	/^    static const char* ToString(LogLevel::Level level);$/;"	p	class:rainbow::LogLevel	access:public	signature:(LogLevel::Level level)
rainbow::LogLevel::UNKNOW	rainbow/log.h	/^        UNKNOW = 0,$/;"	e	enum:rainbow::LogLevel::Level
rainbow::LogLevel::WARN	rainbow/log.h	/^        WARN = 3,$/;"	e	enum:rainbow::LogLevel::Level
rainbow::Logger	rainbow/log.h	/^class Logger : public std::enable_shared_from_this<Logger> {$/;"	c	namespace:rainbow	inherits:std::enable_shared_from_this
rainbow::Logger::Logger	rainbow/log.cpp	/^Logger::Logger(const std::string& name)$/;"	f	class:rainbow::Logger	signature:(const std::string& name)
rainbow::Logger::Logger	rainbow/log.h	/^    Logger(const std::string& name = "root");$/;"	p	class:rainbow::Logger	access:public	signature:(const std::string& name = Ó)
rainbow::Logger::MutexType	rainbow/log.h	/^    typedef Spinlock MutexType;$/;"	t	class:rainbow::Logger	access:public
rainbow::Logger::addAppender	rainbow/log.cpp	/^void Logger::addAppender(LogAppender::ptr appender) {$/;"	f	class:rainbow::Logger	signature:(LogAppender::ptr appender)
rainbow::Logger::addAppender	rainbow/log.h	/^    void addAppender(LogAppender::ptr appender);$/;"	p	class:rainbow::Logger	access:public	signature:(LogAppender::ptr appender)
rainbow::Logger::clearAppenders	rainbow/log.cpp	/^void Logger::clearAppenders() {$/;"	f	class:rainbow::Logger	signature:()
rainbow::Logger::clearAppenders	rainbow/log.h	/^    void clearAppenders();$/;"	p	class:rainbow::Logger	access:public	signature:()
rainbow::Logger::debug	rainbow/log.cpp	/^void Logger::debug(LogEvent::ptr event) { log(LogLevel::DEBUG, event); }$/;"	f	class:rainbow::Logger	signature:(LogEvent::ptr event)
rainbow::Logger::debug	rainbow/log.h	/^    void debug(LogEvent::ptr event);$/;"	p	class:rainbow::Logger	access:public	signature:(LogEvent::ptr event)
rainbow::Logger::delAppender	rainbow/log.cpp	/^void Logger::delAppender(LogAppender::ptr appender) {$/;"	f	class:rainbow::Logger	signature:(LogAppender::ptr appender)
rainbow::Logger::delAppender	rainbow/log.h	/^    void delAppender(LogAppender::ptr appender);$/;"	p	class:rainbow::Logger	access:public	signature:(LogAppender::ptr appender)
rainbow::Logger::error	rainbow/log.cpp	/^void Logger::error(LogEvent::ptr event) { log(LogLevel::ERROR, event); }$/;"	f	class:rainbow::Logger	signature:(LogEvent::ptr event)
rainbow::Logger::error	rainbow/log.h	/^    void error(LogEvent::ptr event);$/;"	p	class:rainbow::Logger	access:public	signature:(LogEvent::ptr event)
rainbow::Logger::fatal	rainbow/log.cpp	/^void Logger::fatal(LogEvent::ptr event) { log(LogLevel::FATAL, event); }$/;"	f	class:rainbow::Logger	signature:(LogEvent::ptr event)
rainbow::Logger::fatal	rainbow/log.h	/^    void fatal(LogEvent::ptr event);$/;"	p	class:rainbow::Logger	access:public	signature:(LogEvent::ptr event)
rainbow::Logger::getFormatter	rainbow/log.cpp	/^LogFormatter::ptr Logger::getFormatter() {$/;"	f	class:rainbow::Logger	signature:()
rainbow::Logger::getFormatter	rainbow/log.h	/^    LogFormatter::ptr getFormatter();$/;"	p	class:rainbow::Logger	access:public	signature:()
rainbow::Logger::getLevel	rainbow/log.h	/^    LogLevel::Level getLevel() const { return m_level; }$/;"	f	class:rainbow::Logger	access:public	signature:() const
rainbow::Logger::getName	rainbow/log.h	/^    const std::string getName() const { return this->m_name; }$/;"	f	class:rainbow::Logger	access:public	signature:() const
rainbow::Logger::info	rainbow/log.cpp	/^void Logger::info(LogEvent::ptr event) { log(LogLevel::INFO, event); }$/;"	f	class:rainbow::Logger	signature:(LogEvent::ptr event)
rainbow::Logger::info	rainbow/log.h	/^    void info(LogEvent::ptr event);$/;"	p	class:rainbow::Logger	access:public	signature:(LogEvent::ptr event)
rainbow::Logger::log	rainbow/log.cpp	/^void Logger::log(LogLevel::Level level, LogEvent::ptr event) {$/;"	f	class:rainbow::Logger	signature:(LogLevel::Level level, LogEvent::ptr event)
rainbow::Logger::log	rainbow/log.h	/^    void log(LogLevel::Level level, LogEvent::ptr event);$/;"	p	class:rainbow::Logger	access:public	signature:(LogLevel::Level level, LogEvent::ptr event)
rainbow::Logger::m_appenders	rainbow/log.h	/^    std::list<LogAppender::ptr> m_appenders;  \/\/ Appenderéå$/;"	m	class:rainbow::Logger	access:private
rainbow::Logger::m_formatter	rainbow/log.h	/^    LogFormatter::ptr m_formatter;            \/\/ æ¥å¿æ ¼å¼$/;"	m	class:rainbow::Logger	access:private
rainbow::Logger::m_level	rainbow/log.h	/^    LogLevel::Level m_level;  \/\/ æ¥å¿å¨ççº§å«$/;"	m	class:rainbow::Logger	access:private
rainbow::Logger::m_mutex	rainbow/log.h	/^    MutexType m_mutex;$/;"	m	class:rainbow::Logger	access:private
rainbow::Logger::m_name	rainbow/log.h	/^    std::string m_name;       \/\/ æ¥å¿åç§°$/;"	m	class:rainbow::Logger	access:private
rainbow::Logger::m_root	rainbow/log.h	/^    Logger::ptr m_root;$/;"	m	class:rainbow::Logger	access:private
rainbow::Logger::ptr	rainbow/log.h	/^    typedef std::shared_ptr<Logger> ptr;$/;"	t	class:rainbow::Logger	access:public
rainbow::Logger::setAppender	rainbow/log.h	/^    void setAppender(LogLevel::Level val) { m_level = val; }$/;"	f	class:rainbow::Logger	access:public	signature:(LogLevel::Level val)
rainbow::Logger::setFormatter	rainbow/log.cpp	/^void Logger::setFormatter(LogFormatter::ptr val) {$/;"	f	class:rainbow::Logger	signature:(LogFormatter::ptr val)
rainbow::Logger::setFormatter	rainbow/log.cpp	/^void Logger::setFormatter(const std::string& val) {$/;"	f	class:rainbow::Logger	signature:(const std::string& val)
rainbow::Logger::setFormatter	rainbow/log.h	/^    void setFormatter(LogFormatter::ptr val);$/;"	p	class:rainbow::Logger	access:public	signature:(LogFormatter::ptr val)
rainbow::Logger::setFormatter	rainbow/log.h	/^    void setFormatter(const std::string& val);$/;"	p	class:rainbow::Logger	access:public	signature:(const std::string& val)
rainbow::Logger::setLevel	rainbow/log.h	/^    void setLevel(LogLevel::Level level) { m_level = level; }$/;"	f	class:rainbow::Logger	access:public	signature:(LogLevel::Level level)
rainbow::Logger::toYamlString	rainbow/log.cpp	/^std::string Logger::toYamlString() {$/;"	f	class:rainbow::Logger	signature:()
rainbow::Logger::toYamlString	rainbow/log.h	/^    std::string toYamlString();$/;"	p	class:rainbow::Logger	access:public	signature:()
rainbow::Logger::warn	rainbow/log.cpp	/^void Logger::warn(LogEvent::ptr event) { log(LogLevel::WARN, event); }$/;"	f	class:rainbow::Logger	signature:(LogEvent::ptr event)
rainbow::Logger::warn	rainbow/log.h	/^    void warn(LogEvent::ptr event);$/;"	p	class:rainbow::Logger	access:public	signature:(LogEvent::ptr event)
rainbow::LoggerManager	rainbow/log.h	/^class LoggerManager {$/;"	c	namespace:rainbow
rainbow::LoggerManager::LoggerManager	rainbow/log.cpp	/^LoggerManager::LoggerManager() {$/;"	f	class:rainbow::LoggerManager	signature:()
rainbow::LoggerManager::LoggerManager	rainbow/log.h	/^    LoggerManager();$/;"	p	class:rainbow::LoggerManager	access:public	signature:()
rainbow::LoggerManager::MutexType	rainbow/log.h	/^    typedef Spinlock MutexType;$/;"	t	class:rainbow::LoggerManager	access:public
rainbow::LoggerManager::getLogger	rainbow/log.cpp	/^Logger::ptr LoggerManager::getLogger(const std::string& name) {$/;"	f	class:rainbow::LoggerManager	signature:(const std::string& name)
rainbow::LoggerManager::getLogger	rainbow/log.h	/^    Logger::ptr getLogger(const std::string& name);$/;"	p	class:rainbow::LoggerManager	access:public	signature:(const std::string& name)
rainbow::LoggerManager::getRoot	rainbow/log.h	/^    Logger::ptr getRoot() const { return m_root; }$/;"	f	class:rainbow::LoggerManager	access:public	signature:() const
rainbow::LoggerManager::init	rainbow/log.cpp	/^void LoggerManager::init() {$/;"	f	class:rainbow::LoggerManager	signature:()
rainbow::LoggerManager::init	rainbow/log.h	/^    void init();$/;"	p	class:rainbow::LoggerManager	access:public	signature:()
rainbow::LoggerManager::m_loggers	rainbow/log.h	/^    std::map<std::string, Logger::ptr> m_loggers;$/;"	m	class:rainbow::LoggerManager	access:private
rainbow::LoggerManager::m_mutex	rainbow/log.h	/^    MutexType m_mutex;$/;"	m	class:rainbow::LoggerManager	access:private
rainbow::LoggerManager::m_root	rainbow/log.h	/^    Logger::ptr m_root;$/;"	m	class:rainbow::LoggerManager	access:private
rainbow::LoggerManager::toYamlString	rainbow/log.cpp	/^std::string LoggerManager::toYamlString() {$/;"	f	class:rainbow::LoggerManager	signature:()
rainbow::LoggerManager::toYamlString	rainbow/log.h	/^    std::string toYamlString();$/;"	p	class:rainbow::LoggerManager	access:public	signature:()
rainbow::LoggerMgr	rainbow/log.h	/^typedef rainbow::Singleton<LoggerManager> LoggerMgr;$/;"	t	namespace:rainbow
rainbow::MallocStackAllocator	rainbow/fiber.cpp	/^class MallocStackAllocator {$/;"	c	namespace:rainbow	file:
rainbow::MallocStackAllocator::Alloc	rainbow/fiber.cpp	/^    static void* Alloc(size_t size) {$/;"	f	class:rainbow::MallocStackAllocator	access:public	signature:(size_t size)
rainbow::MallocStackAllocator::Dealloc	rainbow/fiber.cpp	/^    static void Dealloc(void* vp, size_t size) {$/;"	f	class:rainbow::MallocStackAllocator	access:public	signature:(void* vp, size_t size)
rainbow::MessageFormatItem	rainbow/log.cpp	/^class MessageFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
rainbow::MessageFormatItem::MessageFormatItem	rainbow/log.cpp	/^    MessageFormatItem(const std::string& str = "") {}$/;"	f	class:rainbow::MessageFormatItem	access:public	signature:(const std::string& str = Ó)
rainbow::Mutex	rainbow/thread.h	/^class Mutex {$/;"	c	namespace:rainbow
rainbow::Mutex::Lock	rainbow/thread.h	/^    typedef ScopedLockImpl<Mutex> Lock;$/;"	t	class:rainbow::Mutex	access:public
rainbow::Mutex::Mutex	rainbow/thread.h	/^    Mutex() {$/;"	f	class:rainbow::Mutex	access:public	signature:()
rainbow::Mutex::lock	rainbow/thread.h	/^    void lock() {$/;"	f	class:rainbow::Mutex	access:public	signature:()
rainbow::Mutex::m_mutex	rainbow/thread.h	/^    pthread_mutex_t m_mutex;$/;"	m	class:rainbow::Mutex	access:private
rainbow::Mutex::unlock	rainbow/thread.h	/^    void unlock() {$/;"	f	class:rainbow::Mutex	access:public	signature:()
rainbow::Mutex::~Mutex	rainbow/thread.h	/^    ~Mutex() {$/;"	f	class:rainbow::Mutex	access:public	signature:()
rainbow::NameFormatItem	rainbow/log.cpp	/^class NameFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
rainbow::NameFormatItem::NameFormatItem	rainbow/log.cpp	/^    NameFormatItem(const std::string& str = "") {}$/;"	f	class:rainbow::NameFormatItem	access:public	signature:(const std::string& str = Ó)
rainbow::NewLineFormatItem	rainbow/log.cpp	/^class NewLineFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
rainbow::NewLineFormatItem::NewLineFormatItem	rainbow/log.cpp	/^    NewLineFormatItem(const std::string str = "") {}$/;"	f	class:rainbow::NewLineFormatItem	access:public	signature:(const std::string str = Ó)
rainbow::NullMutex	rainbow/thread.h	/^class NullMutex {$/;"	c	namespace:rainbow
rainbow::NullMutex::Lock	rainbow/thread.h	/^    typedef ScopedLockImpl<NullMutex> Lock;$/;"	t	class:rainbow::NullMutex	access:public
rainbow::NullMutex::NullMutex	rainbow/thread.h	/^    NullMutex() {}$/;"	f	class:rainbow::NullMutex	access:public	signature:()
rainbow::NullMutex::lock	rainbow/thread.h	/^    void lock() {}$/;"	f	class:rainbow::NullMutex	access:public	signature:()
rainbow::NullMutex::unlock	rainbow/thread.h	/^    void unlock() {}$/;"	f	class:rainbow::NullMutex	access:public	signature:()
rainbow::NullRWMutex	rainbow/thread.h	/^class NullRWMutex {$/;"	c	namespace:rainbow
rainbow::NullRWMutex::NullRWMutex	rainbow/thread.h	/^    NullRWMutex() {}$/;"	f	class:rainbow::NullRWMutex	access:public	signature:()
rainbow::NullRWMutex::ReadLock	rainbow/thread.h	/^    typedef ReadScopedLockImpl<NullMutex> ReadLock;$/;"	t	class:rainbow::NullRWMutex	access:public
rainbow::NullRWMutex::WriteLock	rainbow/thread.h	/^    typedef WriteScopedLockImpl<NullMutex> WriteLock;$/;"	t	class:rainbow::NullRWMutex	access:public
rainbow::NullRWMutex::rdlock	rainbow/thread.h	/^    void rdlock() {}$/;"	f	class:rainbow::NullRWMutex	access:public	signature:()
rainbow::NullRWMutex::unlock	rainbow/thread.h	/^    void unlock() {}$/;"	f	class:rainbow::NullRWMutex	access:public	signature:()
rainbow::NullRWMutex::wrlock	rainbow/thread.h	/^    void wrlock() {}$/;"	f	class:rainbow::NullRWMutex	access:public	signature:()
rainbow::NullRWMutex::~NullRWMutex	rainbow/thread.h	/^    ~NullRWMutex() {}$/;"	f	class:rainbow::NullRWMutex	access:public	signature:()
rainbow::OnTimer	rainbow/timer.cpp	/^static void OnTimer(std::weak_ptr<void> weak_cond, std::function<void()> cb) {$/;"	f	namespace:rainbow	signature:(std::weak_ptr<void> weak_cond, std::function<void()> cb)
rainbow::RWMutex	rainbow/thread.h	/^class RWMutex {$/;"	c	namespace:rainbow
rainbow::RWMutex::RWMutex	rainbow/thread.h	/^    RWMutex() {$/;"	f	class:rainbow::RWMutex	access:public	signature:()
rainbow::RWMutex::ReadLock	rainbow/thread.h	/^    typedef ReadScopedLockImpl<RWMutex> ReadLock;$/;"	t	class:rainbow::RWMutex	access:public
rainbow::RWMutex::WriteLock	rainbow/thread.h	/^    typedef WriteScopedLockImpl<RWMutex> WriteLock;$/;"	t	class:rainbow::RWMutex	access:public
rainbow::RWMutex::m_lock	rainbow/thread.h	/^    pthread_rwlock_t m_lock;$/;"	m	class:rainbow::RWMutex	access:private
rainbow::RWMutex::rdlock	rainbow/thread.h	/^    void rdlock() {$/;"	f	class:rainbow::RWMutex	access:public	signature:()
rainbow::RWMutex::unlock	rainbow/thread.h	/^    void unlock() {$/;"	f	class:rainbow::RWMutex	access:public	signature:()
rainbow::RWMutex::wrlock	rainbow/thread.h	/^    void wrlock() {$/;"	f	class:rainbow::RWMutex	access:public	signature:()
rainbow::RWMutex::~RWMutex	rainbow/thread.h	/^    ~RWMutex() {$/;"	f	class:rainbow::RWMutex	access:public	signature:()
rainbow::ReadScopedLockImpl	rainbow/thread.h	/^struct ReadScopedLockImpl {$/;"	s	namespace:rainbow
rainbow::ReadScopedLockImpl::ReadScopedLockImpl	rainbow/thread.h	/^    ReadScopedLockImpl(T& mutex)$/;"	f	struct:rainbow::ReadScopedLockImpl	access:public	signature:(T& mutex)
rainbow::ReadScopedLockImpl::lock	rainbow/thread.h	/^    void lock() {$/;"	f	struct:rainbow::ReadScopedLockImpl	access:public	signature:()
rainbow::ReadScopedLockImpl::m_locked	rainbow/thread.h	/^    bool m_locked;$/;"	m	struct:rainbow::ReadScopedLockImpl	access:private
rainbow::ReadScopedLockImpl::m_mutex	rainbow/thread.h	/^    T& m_mutex;$/;"	m	struct:rainbow::ReadScopedLockImpl	access:private
rainbow::ReadScopedLockImpl::unlock	rainbow/thread.h	/^    void unlock() {$/;"	f	struct:rainbow::ReadScopedLockImpl	access:public	signature:()
rainbow::ReadScopedLockImpl::~ReadScopedLockImpl	rainbow/thread.h	/^    ~ReadScopedLockImpl() {$/;"	f	struct:rainbow::ReadScopedLockImpl	access:public	signature:()
rainbow::Scheduler	rainbow/scheduler.h	/^class Scheduler {$/;"	c	namespace:rainbow
rainbow::Scheduler::FiberAndThread	rainbow/scheduler.h	/^    struct FiberAndThread {$/;"	s	class:rainbow::Scheduler	access:private
rainbow::Scheduler::FiberAndThread::FiberAndThread	rainbow/scheduler.h	/^        FiberAndThread()$/;"	f	struct:rainbow::Scheduler::FiberAndThread	access:public	signature:()
rainbow::Scheduler::FiberAndThread::FiberAndThread	rainbow/scheduler.h	/^        FiberAndThread(Fiber::ptr f, int thr)$/;"	f	struct:rainbow::Scheduler::FiberAndThread	access:public	signature:(Fiber::ptr f, int thr)
rainbow::Scheduler::FiberAndThread::FiberAndThread	rainbow/scheduler.h	/^        FiberAndThread(Fiber::ptr* f, int thr) $/;"	f	struct:rainbow::Scheduler::FiberAndThread	access:public	signature:(Fiber::ptr* f, int thr)
rainbow::Scheduler::FiberAndThread::FiberAndThread	rainbow/scheduler.h	/^        FiberAndThread(std::function<void()> f, int thr) $/;"	f	struct:rainbow::Scheduler::FiberAndThread	access:public	signature:(std::function<void()> f, int thr)
rainbow::Scheduler::FiberAndThread::FiberAndThread	rainbow/scheduler.h	/^        FiberAndThread(std::function<void()>* f, int thr) $/;"	f	struct:rainbow::Scheduler::FiberAndThread	access:public	signature:(std::function<void()>* f, int thr)
rainbow::Scheduler::FiberAndThread::cb	rainbow/scheduler.h	/^        std::function<void()> cb;$/;"	m	struct:rainbow::Scheduler::FiberAndThread	access:public
rainbow::Scheduler::FiberAndThread::fiber	rainbow/scheduler.h	/^        Fiber::ptr fiber;$/;"	m	struct:rainbow::Scheduler::FiberAndThread	access:public
rainbow::Scheduler::FiberAndThread::reset	rainbow/scheduler.h	/^        void reset() {$/;"	f	struct:rainbow::Scheduler::FiberAndThread	access:public	signature:()
rainbow::Scheduler::FiberAndThread::thread	rainbow/scheduler.h	/^        int thread;$/;"	m	struct:rainbow::Scheduler::FiberAndThread	access:public
rainbow::Scheduler::GetMainFiber	rainbow/scheduler.cpp	/^Fiber* Scheduler::GetMainFiber() {$/;"	f	class:rainbow::Scheduler	signature:()
rainbow::Scheduler::GetMainFiber	rainbow/scheduler.h	/^    static Fiber* GetMainFiber();$/;"	p	class:rainbow::Scheduler	access:public	signature:()
rainbow::Scheduler::GetThis	rainbow/scheduler.cpp	/^Scheduler* Scheduler::GetThis() {$/;"	f	class:rainbow::Scheduler	signature:()
rainbow::Scheduler::GetThis	rainbow/scheduler.h	/^    static Scheduler* GetThis();$/;"	p	class:rainbow::Scheduler	access:public	signature:()
rainbow::Scheduler::MutexType	rainbow/scheduler.h	/^    typedef Mutex MutexType;$/;"	t	class:rainbow::Scheduler	access:public
rainbow::Scheduler::Scheduler	rainbow/scheduler.cpp	/^Scheduler::Scheduler(size_t threads, bool use_caller, const std::string& name)$/;"	f	class:rainbow::Scheduler	signature:(size_t threads, bool use_caller, const std::string& name)
rainbow::Scheduler::Scheduler	rainbow/scheduler.h	/^    Scheduler(size_t threads = 1, bool use_caller = true, const std::string& name = "");$/;"	p	class:rainbow::Scheduler	access:public	signature:(size_t threads = 1, bool use_caller = true, const std::string& name = Ó)
rainbow::Scheduler::getName	rainbow/scheduler.h	/^    const std::string& getName() const { return m_name; }$/;"	f	class:rainbow::Scheduler	access:public	signature:() const
rainbow::Scheduler::hasIdleThreads	rainbow/scheduler.h	/^    bool hasIdleThreads() { return m_idleThreadCount > 0; }$/;"	f	class:rainbow::Scheduler	access:protected	signature:()
rainbow::Scheduler::idle	rainbow/scheduler.cpp	/^void Scheduler::idle() {$/;"	f	class:rainbow::Scheduler	signature:()
rainbow::Scheduler::idle	rainbow/scheduler.h	/^    virtual void idle();$/;"	p	class:rainbow::Scheduler	access:protected	signature:()
rainbow::Scheduler::m_activeThreadCount	rainbow/scheduler.h	/^    std::atomic<size_t> m_activeThreadCount = {0};$/;"	m	class:rainbow::Scheduler	access:protected
rainbow::Scheduler::m_autoStop	rainbow/scheduler.h	/^    bool m_autoStop = false;$/;"	m	class:rainbow::Scheduler	access:protected
rainbow::Scheduler::m_fibers	rainbow/scheduler.h	/^    std::list<FiberAndThread> m_fibers;$/;"	m	class:rainbow::Scheduler	access:private
rainbow::Scheduler::m_idleThreadCount	rainbow/scheduler.h	/^    std::atomic<size_t> m_idleThreadCount = {0};$/;"	m	class:rainbow::Scheduler	access:protected
rainbow::Scheduler::m_mutex	rainbow/scheduler.h	/^    MutexType m_mutex;$/;"	m	class:rainbow::Scheduler	access:private
rainbow::Scheduler::m_name	rainbow/scheduler.h	/^    std::string m_name;$/;"	m	class:rainbow::Scheduler	access:private
rainbow::Scheduler::m_rootFiber	rainbow/scheduler.h	/^    Fiber::ptr m_rootFiber;$/;"	m	class:rainbow::Scheduler	access:private
rainbow::Scheduler::m_rootThread	rainbow/scheduler.h	/^    int m_rootThread = 0;$/;"	m	class:rainbow::Scheduler	access:protected
rainbow::Scheduler::m_stopping	rainbow/scheduler.h	/^    bool m_stopping = true;$/;"	m	class:rainbow::Scheduler	access:protected
rainbow::Scheduler::m_threadCount	rainbow/scheduler.h	/^    size_t m_threadCount = 0;$/;"	m	class:rainbow::Scheduler	access:protected
rainbow::Scheduler::m_threadIds	rainbow/scheduler.h	/^    std::vector<int> m_threadIds;$/;"	m	class:rainbow::Scheduler	access:protected
rainbow::Scheduler::m_threads	rainbow/scheduler.h	/^    std::vector<Thread::ptr> m_threads;$/;"	m	class:rainbow::Scheduler	access:private
rainbow::Scheduler::ptr	rainbow/scheduler.h	/^    typedef std::shared_ptr<Scheduler> ptr;$/;"	t	class:rainbow::Scheduler	access:public
rainbow::Scheduler::run	rainbow/scheduler.cpp	/^void Scheduler::run() {$/;"	f	class:rainbow::Scheduler	signature:()
rainbow::Scheduler::run	rainbow/scheduler.h	/^    void run();$/;"	p	class:rainbow::Scheduler	access:protected	signature:()
rainbow::Scheduler::schedule	rainbow/scheduler.h	/^    void schedule(FiberOrCb fc, int thread = -1) {$/;"	f	class:rainbow::Scheduler	access:public	signature:(FiberOrCb fc, int thread = -1)
rainbow::Scheduler::schedule	rainbow/scheduler.h	/^    void schedule(InputIterator begin, InputIterator end) {$/;"	f	class:rainbow::Scheduler	access:public	signature:(InputIterator begin, InputIterator end)
rainbow::Scheduler::scheduleNoLock	rainbow/scheduler.h	/^    bool scheduleNoLock(FiberOrCb fc, int thread) {$/;"	f	class:rainbow::Scheduler	access:private	signature:(FiberOrCb fc, int thread)
rainbow::Scheduler::setThis	rainbow/scheduler.cpp	/^void Scheduler::setThis() {$/;"	f	class:rainbow::Scheduler	signature:()
rainbow::Scheduler::setThis	rainbow/scheduler.h	/^    void setThis();$/;"	p	class:rainbow::Scheduler	access:protected	signature:()
rainbow::Scheduler::start	rainbow/scheduler.cpp	/^void Scheduler::start() {$/;"	f	class:rainbow::Scheduler	signature:()
rainbow::Scheduler::start	rainbow/scheduler.h	/^    void start();$/;"	p	class:rainbow::Scheduler	access:public	signature:()
rainbow::Scheduler::stop	rainbow/scheduler.cpp	/^void Scheduler::stop() {$/;"	f	class:rainbow::Scheduler	signature:()
rainbow::Scheduler::stop	rainbow/scheduler.h	/^    void stop();$/;"	p	class:rainbow::Scheduler	access:public	signature:()
rainbow::Scheduler::stopping	rainbow/scheduler.cpp	/^bool Scheduler::stopping() {$/;"	f	class:rainbow::Scheduler	signature:()
rainbow::Scheduler::stopping	rainbow/scheduler.h	/^    virtual bool stopping();$/;"	p	class:rainbow::Scheduler	access:protected	signature:()
rainbow::Scheduler::tickle	rainbow/scheduler.cpp	/^void Scheduler::tickle() {$/;"	f	class:rainbow::Scheduler	signature:()
rainbow::Scheduler::tickle	rainbow/scheduler.h	/^    virtual void tickle();$/;"	p	class:rainbow::Scheduler	access:protected	signature:()
rainbow::Scheduler::~Scheduler	rainbow/scheduler.cpp	/^Scheduler::~Scheduler() {$/;"	f	class:rainbow::Scheduler	signature:()
rainbow::Scheduler::~Scheduler	rainbow/scheduler.h	/^    virtual ~Scheduler();$/;"	p	class:rainbow::Scheduler	access:public	signature:()
rainbow::ScopedLockImpl	rainbow/thread.h	/^struct ScopedLockImpl {$/;"	s	namespace:rainbow
rainbow::ScopedLockImpl::ScopedLockImpl	rainbow/thread.h	/^    ScopedLockImpl(T& mutex)$/;"	f	struct:rainbow::ScopedLockImpl	access:public	signature:(T& mutex)
rainbow::ScopedLockImpl::lock	rainbow/thread.h	/^    void lock() {$/;"	f	struct:rainbow::ScopedLockImpl	access:public	signature:()
rainbow::ScopedLockImpl::m_locked	rainbow/thread.h	/^    bool m_locked;$/;"	m	struct:rainbow::ScopedLockImpl	access:private
rainbow::ScopedLockImpl::m_mutex	rainbow/thread.h	/^    T& m_mutex;$/;"	m	struct:rainbow::ScopedLockImpl	access:private
rainbow::ScopedLockImpl::unlock	rainbow/thread.h	/^    void unlock() {$/;"	f	struct:rainbow::ScopedLockImpl	access:public	signature:()
rainbow::ScopedLockImpl::~ScopedLockImpl	rainbow/thread.h	/^    ~ScopedLockImpl() {$/;"	f	struct:rainbow::ScopedLockImpl	access:public	signature:()
rainbow::Semaphore	rainbow/thread.h	/^class Semaphore {$/;"	c	namespace:rainbow
rainbow::Semaphore::Semaphore	rainbow/thread.cpp	/^Semaphore::Semaphore(uint32_t count) {$/;"	f	class:rainbow::Semaphore	signature:(uint32_t count)
rainbow::Semaphore::Semaphore	rainbow/thread.h	/^    Semaphore(const Semaphore&&) = delete;$/;"	p	class:rainbow::Semaphore	access:private	signature:(const Semaphore&&)
rainbow::Semaphore::Semaphore	rainbow/thread.h	/^    Semaphore(const Semaphore&) = delete;$/;"	p	class:rainbow::Semaphore	access:private	signature:(const Semaphore&)
rainbow::Semaphore::Semaphore	rainbow/thread.h	/^    Semaphore(uint32_t count = 0);$/;"	p	class:rainbow::Semaphore	access:public	signature:(uint32_t count = 0)
rainbow::Semaphore::m_semaphore	rainbow/thread.h	/^    sem_t m_semaphore;$/;"	m	class:rainbow::Semaphore	access:private
rainbow::Semaphore::notify	rainbow/thread.cpp	/^void Semaphore::notify() {$/;"	f	class:rainbow::Semaphore	signature:()
rainbow::Semaphore::notify	rainbow/thread.h	/^    void notify();$/;"	p	class:rainbow::Semaphore	access:public	signature:()
rainbow::Semaphore::operator =	rainbow/thread.h	/^    Semaphore& operator=(const Semaphore&) = delete;$/;"	p	class:rainbow::Semaphore	access:private	signature:(const Semaphore&)
rainbow::Semaphore::wait	rainbow/thread.cpp	/^void Semaphore::wait() {$/;"	f	class:rainbow::Semaphore	signature:()
rainbow::Semaphore::wait	rainbow/thread.h	/^    void wait();$/;"	p	class:rainbow::Semaphore	access:public	signature:()
rainbow::Semaphore::~Semaphore	rainbow/thread.cpp	/^Semaphore::~Semaphore() {$/;"	f	class:rainbow::Semaphore	signature:()
rainbow::Semaphore::~Semaphore	rainbow/thread.h	/^    ~Semaphore();$/;"	p	class:rainbow::Semaphore	access:public	signature:()
rainbow::Singleton	rainbow/singleton.h	/^class Singleton {$/;"	c	namespace:rainbow
rainbow::Singleton::GetInstance	rainbow/singleton.h	/^    static T* GetInstance() {$/;"	f	class:rainbow::Singleton	access:public	signature:()
rainbow::Singletonptr	rainbow/singleton.h	/^class Singletonptr {$/;"	c	namespace:rainbow
rainbow::Singletonptr::GetInstance	rainbow/singleton.h	/^    static std::shared_ptr<T> GetInstance() {$/;"	f	class:rainbow::Singletonptr	access:public	signature:()
rainbow::Spinlock	rainbow/thread.h	/^class Spinlock {$/;"	c	namespace:rainbow
rainbow::Spinlock::Lock	rainbow/thread.h	/^    typedef ScopedLockImpl<Spinlock> Lock;$/;"	t	class:rainbow::Spinlock	access:public
rainbow::Spinlock::Spinlock	rainbow/thread.h	/^    Spinlock() {$/;"	f	class:rainbow::Spinlock	access:public	signature:()
rainbow::Spinlock::lock	rainbow/thread.h	/^    void lock() {$/;"	f	class:rainbow::Spinlock	access:public	signature:()
rainbow::Spinlock::m_mutex	rainbow/thread.h	/^    pthread_spinlock_t m_mutex;$/;"	m	class:rainbow::Spinlock	access:private
rainbow::Spinlock::unlock	rainbow/thread.h	/^    void unlock() {$/;"	f	class:rainbow::Spinlock	access:public	signature:()
rainbow::Spinlock::~Spinlock	rainbow/thread.h	/^    ~Spinlock() {$/;"	f	class:rainbow::Spinlock	access:public	signature:()
rainbow::StdoutLogAppender	rainbow/log.h	/^class StdoutLogAppender : public LogAppender {$/;"	c	namespace:rainbow	inherits:LogAppender
rainbow::StdoutLogAppender::log	rainbow/log.cpp	/^void StdoutLogAppender::log(std::shared_ptr<Logger> logger,$/;"	f	class:rainbow::StdoutLogAppender	signature:(std::shared_ptr<Logger> logger, LogLevel::Level level, LogEvent::ptr event)
rainbow::StdoutLogAppender::override	rainbow/log.h	/^                     LogEvent::ptr event) override;$/;"	m	class:rainbow::StdoutLogAppender	access:public
rainbow::StdoutLogAppender::override	rainbow/log.h	/^    std::string toYamlString() override;$/;"	m	class:rainbow::StdoutLogAppender	access:public
rainbow::StdoutLogAppender::ptr	rainbow/log.h	/^    typedef std::shared_ptr<StdoutLogAppender> ptr;$/;"	t	class:rainbow::StdoutLogAppender	access:public
rainbow::StdoutLogAppender::toYamlString	rainbow/log.cpp	/^std::string StdoutLogAppender::toYamlString() {$/;"	f	class:rainbow::StdoutLogAppender	signature:()
rainbow::StringFormatItem	rainbow/log.cpp	/^class StringFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
rainbow::StringFormatItem::StringFormatItem	rainbow/log.cpp	/^    StringFormatItem(const std::string& str) : m_string(str) {}$/;"	f	class:rainbow::StringFormatItem	access:public	signature:(const std::string& str)
rainbow::StringFormatItem::getString	rainbow/log.cpp	/^    std::string getString() const { return m_string; }$/;"	f	class:rainbow::StringFormatItem	access:public	signature:() const
rainbow::StringFormatItem::m_string	rainbow/log.cpp	/^    std::string m_string;$/;"	m	class:rainbow::StringFormatItem	file:	access:private
rainbow::TabFormatItem	rainbow/log.cpp	/^class TabFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
rainbow::TabFormatItem::TabFormatItem	rainbow/log.cpp	/^     TabFormatItem(const std::string& str = "") {}$/;"	f	class:rainbow::TabFormatItem	access:public	signature:(const std::string& str = Ó)
rainbow::Thread	rainbow/thread.h	/^class Thread {$/;"	c	namespace:rainbow
rainbow::Thread::GetName	rainbow/thread.cpp	/^const std::string& Thread::GetName() {$/;"	f	class:rainbow::Thread	signature:()
rainbow::Thread::GetName	rainbow/thread.h	/^    static const std::string& GetName();$/;"	p	class:rainbow::Thread	access:public	signature:()
rainbow::Thread::GetThis	rainbow/thread.cpp	/^Thread* Thread::GetThis() {$/;"	f	class:rainbow::Thread	signature:()
rainbow::Thread::GetThis	rainbow/thread.h	/^    static Thread* GetThis();$/;"	p	class:rainbow::Thread	access:public	signature:()
rainbow::Thread::SetName	rainbow/thread.cpp	/^void Thread::SetName(const std::string& name) {$/;"	f	class:rainbow::Thread	signature:(const std::string& name)
rainbow::Thread::SetName	rainbow/thread.h	/^    static void SetName(const std::string& name);$/;"	p	class:rainbow::Thread	access:public	signature:(const std::string& name)
rainbow::Thread::Thread	rainbow/thread.cpp	/^Thread::Thread(std::function<void()> cb, const std::string& name) $/;"	f	class:rainbow::Thread	signature:(std::function<void()> cb, const std::string& name)
rainbow::Thread::Thread	rainbow/thread.h	/^    Thread(const Thread&&) = delete;$/;"	p	class:rainbow::Thread	access:private	signature:(const Thread&&)
rainbow::Thread::Thread	rainbow/thread.h	/^    Thread(const Thread&) = delete;$/;"	p	class:rainbow::Thread	access:private	signature:(const Thread&)
rainbow::Thread::Thread	rainbow/thread.h	/^    Thread(std::function<void()> cb, const std::string& name);$/;"	p	class:rainbow::Thread	access:public	signature:(std::function<void()> cb, const std::string& name)
rainbow::Thread::getId	rainbow/thread.h	/^    pid_t getId() const { return m_id; }$/;"	f	class:rainbow::Thread	access:public	signature:() const
rainbow::Thread::getName	rainbow/thread.h	/^    const std::string& getName() const { return m_name; }$/;"	f	class:rainbow::Thread	access:public	signature:() const
rainbow::Thread::join	rainbow/thread.cpp	/^void Thread::join() {$/;"	f	class:rainbow::Thread	signature:()
rainbow::Thread::join	rainbow/thread.h	/^    void join();$/;"	p	class:rainbow::Thread	access:public	signature:()
rainbow::Thread::m_cb	rainbow/thread.h	/^    std::function<void()> m_cb;$/;"	m	class:rainbow::Thread	access:private
rainbow::Thread::m_id	rainbow/thread.h	/^    pid_t m_id;$/;"	m	class:rainbow::Thread	access:private
rainbow::Thread::m_name	rainbow/thread.h	/^    std::string m_name;$/;"	m	class:rainbow::Thread	access:private
rainbow::Thread::m_semaphore	rainbow/thread.h	/^    Semaphore m_semaphore;$/;"	m	class:rainbow::Thread	access:private
rainbow::Thread::m_thread	rainbow/thread.h	/^    pthread_t m_thread;$/;"	m	class:rainbow::Thread	access:private
rainbow::Thread::operator =	rainbow/thread.h	/^    Thread& operator=(const Thread&) = delete;$/;"	p	class:rainbow::Thread	access:private	signature:(const Thread&)
rainbow::Thread::ptr	rainbow/thread.h	/^    typedef std::shared_ptr<Thread> ptr;$/;"	t	class:rainbow::Thread	access:public
rainbow::Thread::run	rainbow/thread.cpp	/^void* Thread::run(void* arg) {$/;"	f	class:rainbow::Thread	signature:(void* arg)
rainbow::Thread::run	rainbow/thread.h	/^    static void* run(void* arg);$/;"	p	class:rainbow::Thread	access:private	signature:(void* arg)
rainbow::Thread::~Thread	rainbow/thread.cpp	/^Thread::~Thread() {$/;"	f	class:rainbow::Thread	signature:()
rainbow::Thread::~Thread	rainbow/thread.h	/^    ~Thread();$/;"	p	class:rainbow::Thread	access:public	signature:()
rainbow::ThreadIdFormatItem	rainbow/log.cpp	/^class ThreadIdFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
rainbow::ThreadIdFormatItem::ThreadIdFormatItem	rainbow/log.cpp	/^    ThreadIdFormatItem(const std::string str = "") {}$/;"	f	class:rainbow::ThreadIdFormatItem	access:public	signature:(const std::string str = Ó)
rainbow::ThreadNameFormatItem	rainbow/log.cpp	/^class ThreadNameFormatItem : public LogFormatter::FormatItem {$/;"	c	namespace:rainbow	file:	inherits:LogFormatter::FormatItem
rainbow::ThreadNameFormatItem::ThreadNameFormatItem	rainbow/log.cpp	/^    ThreadNameFormatItem(const std::string str = "") {}$/;"	f	class:rainbow::ThreadNameFormatItem	access:public	signature:(const std::string str = Ó)
rainbow::Timer	rainbow/timer.h	/^class Timer : public std::enable_shared_from_this<Timer> {$/;"	c	namespace:rainbow	inherits:std::enable_shared_from_this
rainbow::Timer::Comparator	rainbow/timer.h	/^    struct Comparator {$/;"	s	class:rainbow::Timer	access:private
rainbow::Timer::Comparator::operator ()	rainbow/timer.cpp	/^bool Timer::Comparator::operator()(const Timer::ptr& lhs$/;"	f	class:rainbow::Timer::Comparator	signature:(const Timer::ptr& lhs ,const Timer::ptr& rhs) const
rainbow::Timer::Comparator::operator ()	rainbow/timer.h	/^        bool operator() (const Timer::ptr& lhs, const Timer::ptr& rhs) const;$/;"	p	struct:rainbow::Timer::Comparator	access:public	signature:(const Timer::ptr& lhs, const Timer::ptr& rhs) const
rainbow::Timer::Timer	rainbow/timer.cpp	/^Timer::Timer(uint64_t ms, std::function<void()> cb,$/;"	f	class:rainbow::Timer	signature:(uint64_t ms, std::function<void()> cb, bool recurring, TimerManager* manager)
rainbow::Timer::Timer	rainbow/timer.cpp	/^Timer::Timer(uint64_t next) $/;"	f	class:rainbow::Timer	signature:(uint64_t next)
rainbow::Timer::Timer	rainbow/timer.h	/^    Timer(uint64_t ms, std::function<void()> cb,$/;"	p	class:rainbow::Timer	access:private	signature:(uint64_t ms, std::function<void()> cb, bool recurring, TimerManager* manager)
rainbow::Timer::Timer	rainbow/timer.h	/^    Timer(uint64_t next);$/;"	p	class:rainbow::Timer	access:private	signature:(uint64_t next)
rainbow::Timer::cancel	rainbow/timer.cpp	/^bool Timer::cancel() {$/;"	f	class:rainbow::Timer	signature:()
rainbow::Timer::cancel	rainbow/timer.h	/^    bool cancel();$/;"	p	class:rainbow::Timer	access:private	signature:()
rainbow::Timer::m_cb	rainbow/timer.h	/^    std::function<void()> m_cb;$/;"	m	class:rainbow::Timer	access:private
rainbow::Timer::m_manager	rainbow/timer.h	/^    TimerManager* m_manager = nullptr;$/;"	m	class:rainbow::Timer	access:private
rainbow::Timer::m_ms	rainbow/timer.h	/^    uint64_t m_ms = 0; $/;"	m	class:rainbow::Timer	access:private
rainbow::Timer::m_next	rainbow/timer.h	/^    uint64_t m_next = 0;$/;"	m	class:rainbow::Timer	access:private
rainbow::Timer::m_recurring	rainbow/timer.h	/^    bool m_recurring = false;$/;"	m	class:rainbow::Timer	access:private
rainbow::Timer::ptr	rainbow/timer.h	/^    typedef std::shared_ptr<Timer> ptr;$/;"	t	class:rainbow::Timer	access:public
rainbow::Timer::refresh	rainbow/timer.cpp	/^bool Timer::refresh() {$/;"	f	class:rainbow::Timer	signature:()
rainbow::Timer::refresh	rainbow/timer.h	/^    bool refresh();$/;"	p	class:rainbow::Timer	access:private	signature:()
rainbow::Timer::reset	rainbow/timer.cpp	/^bool Timer::reset(uint64_t ms, bool from_now) {$/;"	f	class:rainbow::Timer	signature:(uint64_t ms, bool from_now)
rainbow::Timer::reset	rainbow/timer.h	/^    bool reset(uint64_t ms, bool from_now);$/;"	p	class:rainbow::Timer	access:private	signature:(uint64_t ms, bool from_now)
rainbow::TimerManager	rainbow/timer.h	/^class TimerManager {$/;"	c	namespace:rainbow
rainbow::TimerManager::RWMutexType	rainbow/timer.h	/^    typedef RWMutex RWMutexType;$/;"	t	class:rainbow::TimerManager	access:public
rainbow::TimerManager::TimerManager	rainbow/timer.cpp	/^TimerManager::TimerManager() {$/;"	f	class:rainbow::TimerManager	signature:()
rainbow::TimerManager::TimerManager	rainbow/timer.h	/^    TimerManager();$/;"	p	class:rainbow::TimerManager	access:public	signature:()
rainbow::TimerManager::addConditionTimer	rainbow/timer.cpp	/^Timer::ptr TimerManager::addConditionTimer(uint64_t ms, std::function<void()> cb$/;"	f	class:rainbow::TimerManager	signature:(uint64_t ms, std::function<void()> cb ,std::weak_ptr<void> weak_cond ,bool recurring)
rainbow::TimerManager::addConditionTimer	rainbow/timer.h	/^    Timer::ptr addConditionTimer(uint64_t ms, std::function<void()> cb$/;"	p	class:rainbow::TimerManager	access:public	signature:(uint64_t ms, std::function<void()> cb ,std::weak_ptr<void> weak_cond ,bool recurring = false)
rainbow::TimerManager::addTimer	rainbow/timer.cpp	/^Timer::ptr TimerManager::addTimer(uint64_t ms, std::function<void()> cb$/;"	f	class:rainbow::TimerManager	signature:(uint64_t ms, std::function<void()> cb ,bool recurring)
rainbow::TimerManager::addTimer	rainbow/timer.cpp	/^void TimerManager::addTimer(Timer::ptr val, RWMutexType::WriteLock& lock) {$/;"	f	class:rainbow::TimerManager	signature:(Timer::ptr val, RWMutexType::WriteLock& lock)
rainbow::TimerManager::addTimer	rainbow/timer.h	/^    Timer::ptr addTimer(uint64_t ms, std::function<void()> cb$/;"	p	class:rainbow::TimerManager	access:public	signature:(uint64_t ms, std::function<void()> cb ,bool recurring = false)
rainbow::TimerManager::addTimer	rainbow/timer.h	/^    void addTimer(Timer::ptr val, RWMutexType::WriteLock& lock);$/;"	p	class:rainbow::TimerManager	access:protected	signature:(Timer::ptr val, RWMutexType::WriteLock& lock)
rainbow::TimerManager::detectClockRollover	rainbow/timer.cpp	/^bool TimerManager::detectClockRollover(uint64_t now_ms) {$/;"	f	class:rainbow::TimerManager	signature:(uint64_t now_ms)
rainbow::TimerManager::detectClockRollover	rainbow/timer.h	/^    bool detectClockRollover(uint64_t now_ms);$/;"	p	class:rainbow::TimerManager	access:private	signature:(uint64_t now_ms)
rainbow::TimerManager::getNextTimer	rainbow/timer.cpp	/^uint64_t TimerManager::getNextTimer() {$/;"	f	class:rainbow::TimerManager	signature:()
rainbow::TimerManager::getNextTimer	rainbow/timer.h	/^    uint64_t getNextTimer();$/;"	p	class:rainbow::TimerManager	access:public	signature:()
rainbow::TimerManager::hasTimer	rainbow/timer.cpp	/^bool TimerManager::hasTimer() {$/;"	f	class:rainbow::TimerManager	signature:()
rainbow::TimerManager::hasTimer	rainbow/timer.h	/^    bool hasTimer();$/;"	p	class:rainbow::TimerManager	access:protected	signature:()
rainbow::TimerManager::listExpiredCb	rainbow/timer.cpp	/^void TimerManager::listExpiredCb(std::vector<std::function<void()>>& cbs) {$/;"	f	class:rainbow::TimerManager	signature:(std::vector<std::function<void()>>& cbs)
rainbow::TimerManager::listExpiredCb	rainbow/timer.h	/^    void listExpiredCb(std::vector<std::function<void()>>& cbs);$/;"	p	class:rainbow::TimerManager	access:public	signature:(std::vector<std::function<void()>>& cbs)
rainbow::TimerManager::m_mutex	rainbow/timer.h	/^    RWMutexType m_mutex;$/;"	m	class:rainbow::TimerManager	access:private
rainbow::TimerManager::m_previouseTime	rainbow/timer.h	/^    uint64_t m_previouseTime = 0;$/;"	m	class:rainbow::TimerManager	access:private
rainbow::TimerManager::m_tickled	rainbow/timer.h	/^    bool m_tickled = false;$/;"	m	class:rainbow::TimerManager	access:private
rainbow::TimerManager::m_timers	rainbow/timer.h	/^    std::set<Timer::ptr, Timer::Comparator> m_timers;$/;"	m	class:rainbow::TimerManager	access:private
rainbow::TimerManager::onTimerInsertedAtFront	rainbow/timer.h	/^    virtual void onTimerInsertedAtFront() = 0;$/;"	p	class:rainbow::TimerManager	access:protected	signature:()
rainbow::TimerManager::~TimerManager	rainbow/timer.cpp	/^TimerManager::~TimerManager() {$/;"	f	class:rainbow::TimerManager	signature:()
rainbow::TimerManager::~TimerManager	rainbow/timer.h	/^    virtual ~TimerManager();$/;"	p	class:rainbow::TimerManager	access:public	signature:()
rainbow::WriteScopedLockImpl	rainbow/thread.h	/^struct WriteScopedLockImpl {$/;"	s	namespace:rainbow
rainbow::WriteScopedLockImpl::WriteScopedLockImpl	rainbow/thread.h	/^    WriteScopedLockImpl(T& mutex)$/;"	f	struct:rainbow::WriteScopedLockImpl	access:public	signature:(T& mutex)
rainbow::WriteScopedLockImpl::lock	rainbow/thread.h	/^    void lock() {$/;"	f	struct:rainbow::WriteScopedLockImpl	access:public	signature:()
rainbow::WriteScopedLockImpl::m_locked	rainbow/thread.h	/^    bool m_locked;$/;"	m	struct:rainbow::WriteScopedLockImpl	access:private
rainbow::WriteScopedLockImpl::m_mutex	rainbow/thread.h	/^    T& m_mutex;$/;"	m	struct:rainbow::WriteScopedLockImpl	access:private
rainbow::WriteScopedLockImpl::unlock	rainbow/thread.h	/^    void unlock() {$/;"	f	struct:rainbow::WriteScopedLockImpl	access:public	signature:()
rainbow::WriteScopedLockImpl::~WriteScopedLockImpl	rainbow/thread.h	/^    ~WriteScopedLockImpl() {$/;"	f	struct:rainbow::WriteScopedLockImpl	access:public	signature:()
rainbow::__log_init	rainbow/log.cpp	/^static LogIniter __log_init;$/;"	m	namespace:rainbow	file:
rainbow::g_fiber_stack_size	rainbow/fiber.cpp	/^static ConfigVar<uint32_t>::ptr g_fiber_stack_size = $/;"	m	namespace:rainbow	file:
rainbow::g_log_define	rainbow/log.cpp	/^rainbow::ConfigVar<std::set<LogDefine>>::ptr g_log_define = $/;"	m	namespace:rainbow	file:
rainbow::g_logger	rainbow/config.cpp	/^static rainbow::Logger::ptr g_logger = RAINBOW_LOG_NAME("system");$/;"	m	namespace:rainbow	file:
rainbow::g_logger	rainbow/fiber.cpp	/^static Logger::ptr g_logger = RAINBOW_LOG_NAME("system");$/;"	m	namespace:rainbow	file:
rainbow::g_logger	rainbow/iomanager.cpp	/^static rainbow::Logger::ptr g_logger = RAINBOW_LOG_NAME("system");$/;"	m	namespace:rainbow	file:
rainbow::g_logger	rainbow/scheduler.cpp	/^static rainbow::Logger::ptr g_logger = RAINBOW_LOG_NAME("system");$/;"	m	namespace:rainbow	file:
rainbow::g_logger	rainbow/thread.cpp	/^static rainbow::Logger::ptr g_logger = RAINBOW_LOG_NAME("system");$/;"	m	namespace:rainbow	file:
rainbow::g_logger	rainbow/util.cpp	/^rainbow::Logger::ptr g_logger = RAINBOW_LOG_NAME("system");$/;"	m	namespace:rainbow	file:
rainbow::t_fiber	rainbow/fiber.cpp	/^static thread_local Fiber* t_fiber = nullptr;$/;"	m	namespace:rainbow	file:
rainbow::t_fiber	rainbow/scheduler.cpp	/^static thread_local Fiber* t_fiber = nullptr;$/;"	m	namespace:rainbow	file:
rainbow::t_scheduler	rainbow/scheduler.cpp	/^static thread_local Scheduler* t_scheduler = nullptr;$/;"	m	namespace:rainbow	file:
rainbow::t_thread	rainbow/thread.cpp	/^static thread_local Thread* t_thread = nullptr;$/;"	m	namespace:rainbow	file:
rainbow::t_threadFiber	rainbow/fiber.cpp	/^static thread_local Fiber::ptr t_threadFiber = nullptr;$/;"	m	namespace:rainbow	file:
rainbow::t_thread_name	rainbow/thread.cpp	/^static thread_local std::string t_thread_name = "UNKNOW";$/;"	m	namespace:rainbow	file:
rdlock	rainbow/thread.h	/^    void rdlock() {$/;"	f	class:rainbow::RWMutex	access:public	signature:()
rdlock	rainbow/thread.h	/^    void rdlock() {}$/;"	f	class:rainbow::NullRWMutex	access:public	signature:()
read	rainbow/iomanager.h	/^        EventContext read;      \/\/ è¯»äºä»¶$/;"	m	struct:rainbow::IOManager::FdContext	access:public
refresh	rainbow/timer.cpp	/^bool Timer::refresh() {$/;"	f	class:rainbow::Timer	signature:()
refresh	rainbow/timer.h	/^    bool refresh();$/;"	p	class:rainbow::Timer	access:private	signature:()
reopen	rainbow/log.cpp	/^bool FileLogAppender::reopen() {$/;"	f	class:rainbow::FileLogAppender	signature:()
reopen	rainbow/log.h	/^    bool reopen();$/;"	p	class:rainbow::FileLogAppender	access:public	signature:()
reset	rainbow/fiber.cpp	/^void Fiber::reset(std::function<void()> cb) {$/;"	f	class:rainbow::Fiber	signature:(std::function<void()> cb)
reset	rainbow/fiber.h	/^    void reset(std::function<void()> cb);$/;"	p	class:rainbow::Fiber	access:public	signature:(std::function<void()> cb)
reset	rainbow/scheduler.h	/^        void reset() {$/;"	f	struct:rainbow::Scheduler::FiberAndThread	access:public	signature:()
reset	rainbow/timer.cpp	/^bool Timer::reset(uint64_t ms, bool from_now) {$/;"	f	class:rainbow::Timer	signature:(uint64_t ms, bool from_now)
reset	rainbow/timer.h	/^    bool reset(uint64_t ms, bool from_now);$/;"	p	class:rainbow::Timer	access:private	signature:(uint64_t ms, bool from_now)
resetContext	rainbow/iomanager.cpp	/^void IOManager::FdContext::resetContext(EventContext& ctx) {$/;"	f	class:rainbow::IOManager::FdContext	signature:(EventContext& ctx)
resetContext	rainbow/iomanager.h	/^        void resetContext(EventContext& ctx);$/;"	p	struct:rainbow::IOManager::FdContext	access:public	signature:(EventContext& ctx)
run	rainbow/scheduler.cpp	/^void Scheduler::run() {$/;"	f	class:rainbow::Scheduler	signature:()
run	rainbow/scheduler.h	/^    void run();$/;"	p	class:rainbow::Scheduler	access:protected	signature:()
run	rainbow/thread.cpp	/^void* Thread::run(void* arg) {$/;"	f	class:rainbow::Thread	signature:(void* arg)
run	rainbow/thread.h	/^    static void* run(void* arg);$/;"	p	class:rainbow::Thread	access:private	signature:(void* arg)
run_in_fiber	tests/test_fiber.cpp	/^void run_in_fiber() {$/;"	f	signature:()
s_mutex	tests/test_thread.cpp	/^rainbow::Mutex s_mutex;$/;"	v
schedule	rainbow/scheduler.h	/^    void schedule(FiberOrCb fc, int thread = -1) {$/;"	f	class:rainbow::Scheduler	access:public	signature:(FiberOrCb fc, int thread = -1)
schedule	rainbow/scheduler.h	/^    void schedule(InputIterator begin, InputIterator end) {$/;"	f	class:rainbow::Scheduler	access:public	signature:(InputIterator begin, InputIterator end)
scheduleNoLock	rainbow/scheduler.h	/^    bool scheduleNoLock(FiberOrCb fc, int thread) {$/;"	f	class:rainbow::Scheduler	access:private	signature:(FiberOrCb fc, int thread)
scheduler	rainbow/iomanager.h	/^            Scheduler* scheduler = nullptr;           \/\/ äºä»¶æ§è¡ç scheduler$/;"	m	struct:rainbow::IOManager::FdContext::EventContext	access:public
setAppender	rainbow/log.h	/^    void setAppender(LogLevel::Level val) { m_level = val; }$/;"	f	class:rainbow::Logger	access:public	signature:(LogLevel::Level val)
setFormatter	rainbow/log.cpp	/^void LogAppender::setFormatter(LogFormatter::ptr val) {$/;"	f	class:rainbow::LogAppender	signature:(LogFormatter::ptr val)
setFormatter	rainbow/log.cpp	/^void Logger::setFormatter(LogFormatter::ptr val) {$/;"	f	class:rainbow::Logger	signature:(LogFormatter::ptr val)
setFormatter	rainbow/log.cpp	/^void Logger::setFormatter(const std::string& val) {$/;"	f	class:rainbow::Logger	signature:(const std::string& val)
setFormatter	rainbow/log.h	/^    void setFormatter(LogFormatter::ptr val);$/;"	p	class:rainbow::LogAppender	access:public	signature:(LogFormatter::ptr val)
setFormatter	rainbow/log.h	/^    void setFormatter(LogFormatter::ptr val);$/;"	p	class:rainbow::Logger	access:public	signature:(LogFormatter::ptr val)
setFormatter	rainbow/log.h	/^    void setFormatter(const std::string& val);$/;"	p	class:rainbow::Logger	access:public	signature:(const std::string& val)
setLevel	rainbow/log.cpp	/^void LogAppender::setLevel(const LogLevel::Level& level) {$/;"	f	class:rainbow::LogAppender	signature:(const LogLevel::Level& level)
setLevel	rainbow/log.h	/^    void setLevel(LogLevel::Level level) { m_level = level; }$/;"	f	class:rainbow::Logger	access:public	signature:(LogLevel::Level level)
setLevel	rainbow/log.h	/^    void setLevel(const LogLevel::Level& level);$/;"	p	class:rainbow::LogAppender	access:public	signature:(const LogLevel::Level& level)
setState	rainbow/fiber.h	/^    void setState(const State state) { m_state = state; }$/;"	f	class:rainbow::Fiber	access:public	signature:(const State state)
setThis	rainbow/scheduler.cpp	/^void Scheduler::setThis() {$/;"	f	class:rainbow::Scheduler	signature:()
setThis	rainbow/scheduler.h	/^    void setThis();$/;"	p	class:rainbow::Scheduler	access:protected	signature:()
setValue	rainbow/config.h	/^    void setValue(const T& v) { $/;"	f	class:rainbow::ConfigVar	access:public	signature:(const T& v)
srcdirs	Makefile	/^srcdirs := rainbow tests$/;"	m
srcs	Makefile	/^srcs := timer.cpp iomanager.cpp scheduler.cpp fiber.cpp thread.cpp config.cpp log.cpp util.cpp test_iomanager.cpp$/;"	m
start	rainbow/scheduler.cpp	/^void Scheduler::start() {$/;"	f	class:rainbow::Scheduler	signature:()
start	rainbow/scheduler.h	/^    void start();$/;"	p	class:rainbow::Scheduler	access:public	signature:()
stop	rainbow/scheduler.cpp	/^void Scheduler::stop() {$/;"	f	class:rainbow::Scheduler	signature:()
stop	rainbow/scheduler.h	/^    void stop();$/;"	p	class:rainbow::Scheduler	access:public	signature:()
stopping	rainbow/iomanager.cpp	/^bool IOManager::stopping() {$/;"	f	class:rainbow::IOManager	signature:()
stopping	rainbow/scheduler.cpp	/^bool Scheduler::stopping() {$/;"	f	class:rainbow::Scheduler	signature:()
stopping	rainbow/scheduler.h	/^    virtual bool stopping();$/;"	p	class:rainbow::Scheduler	access:protected	signature:()
swapIn	rainbow/fiber.cpp	/^void Fiber::swapIn() {$/;"	f	class:rainbow::Fiber	signature:()
swapIn	rainbow/fiber.h	/^    void swapIn();$/;"	p	class:rainbow::Fiber	access:public	signature:()
swapOut	rainbow/fiber.cpp	/^void Fiber::swapOut() {$/;"	f	class:rainbow::Fiber	signature:()
swapOut	rainbow/fiber.h	/^    void swapOut();$/;"	p	class:rainbow::Fiber	access:public	signature:()
t_fiber	rainbow/fiber.cpp	/^static thread_local Fiber* t_fiber = nullptr;$/;"	m	namespace:rainbow	file:
t_fiber	rainbow/scheduler.cpp	/^static thread_local Fiber* t_fiber = nullptr;$/;"	m	namespace:rainbow	file:
t_scheduler	rainbow/scheduler.cpp	/^static thread_local Scheduler* t_scheduler = nullptr;$/;"	m	namespace:rainbow	file:
t_thread	rainbow/thread.cpp	/^static thread_local Thread* t_thread = nullptr;$/;"	m	namespace:rainbow	file:
t_threadFiber	rainbow/fiber.cpp	/^static thread_local Fiber::ptr t_threadFiber = nullptr;$/;"	m	namespace:rainbow	file:
t_thread_name	rainbow/thread.cpp	/^static thread_local std::string t_thread_name = "UNKNOW";$/;"	m	namespace:rainbow	file:
target	Makefile	/^target := bin\/test_iomanager$/;"	m
test1	tests/test_iomanager.cpp	/^void test1() {$/;"	f	signature:()
test_assert	tests/test_util.cpp	/^void test_assert() {$/;"	f	signature:()
test_class	tests/test_config.cpp	/^void test_class() {$/;"	f	signature:()
test_fiber	tests/test_fiber.cpp	/^void test_fiber() {$/;"	f	signature:()
test_fiber	tests/test_iomanager.cpp	/^void test_fiber() {$/;"	f	signature:()
test_fiber	tests/test_scheduler.cpp	/^void test_fiber()$/;"	f	signature:()
test_log	tests/test_config.cpp	/^void test_log() {$/;"	f	signature:()
test_timer	tests/test_iomanager.cpp	/^void test_timer() {$/;"	f	signature:()
thread	rainbow/scheduler.h	/^        int thread;$/;"	m	struct:rainbow::Scheduler::FiberAndThread	access:public
tickle	rainbow/iomanager.cpp	/^void IOManager::tickle() {$/;"	f	class:rainbow::IOManager	signature:()
tickle	rainbow/scheduler.cpp	/^void Scheduler::tickle() {$/;"	f	class:rainbow::Scheduler	signature:()
tickle	rainbow/scheduler.h	/^    virtual void tickle();$/;"	p	class:rainbow::Scheduler	access:protected	signature:()
toString	rainbow/config.h	/^    virtual std::string toString() = 0;$/;"	p	class:rainbow::ConfigVarBase	access:public	signature:()
toString	tests/test_config.cpp	/^    std::string toString() const {$/;"	f	class:Person	access:public	signature:() const
toYamlString	rainbow/log.cpp	/^std::string FileLogAppender::toYamlString() {$/;"	f	class:rainbow::FileLogAppender	signature:()
toYamlString	rainbow/log.cpp	/^std::string Logger::toYamlString() {$/;"	f	class:rainbow::Logger	signature:()
toYamlString	rainbow/log.cpp	/^std::string LoggerManager::toYamlString() {$/;"	f	class:rainbow::LoggerManager	signature:()
toYamlString	rainbow/log.cpp	/^std::string StdoutLogAppender::toYamlString() {$/;"	f	class:rainbow::StdoutLogAppender	signature:()
toYamlString	rainbow/log.h	/^    std::string toYamlString();$/;"	p	class:rainbow::Logger	access:public	signature:()
toYamlString	rainbow/log.h	/^    std::string toYamlString();$/;"	p	class:rainbow::LoggerManager	access:public	signature:()
toYamlString	rainbow/log.h	/^    virtual std::string toYamlString() = 0;$/;"	p	class:rainbow::LogAppender	access:public	signature:()
triggerEvent	rainbow/iomanager.cpp	/^void IOManager::FdContext::triggerEvent(IOManager::Event event) {$/;"	f	class:rainbow::IOManager::FdContext	signature:(IOManager::Event event)
triggerEvent	rainbow/iomanager.h	/^        void triggerEvent(Event event);$/;"	p	struct:rainbow::IOManager::FdContext	access:public	signature:(Event event)
type	rainbow/log.cpp	/^    int type = 0; \/\/ 1 File, 2 Stdout$/;"	m	struct:rainbow::LogAppenderDefine	file:	access:public
unlock	rainbow/thread.h	/^    void unlock() {$/;"	f	class:rainbow::CASLock	access:public	signature:()
unlock	rainbow/thread.h	/^    void unlock() {$/;"	f	class:rainbow::Mutex	access:public	signature:()
unlock	rainbow/thread.h	/^    void unlock() {$/;"	f	class:rainbow::RWMutex	access:public	signature:()
unlock	rainbow/thread.h	/^    void unlock() {$/;"	f	class:rainbow::Spinlock	access:public	signature:()
unlock	rainbow/thread.h	/^    void unlock() {$/;"	f	struct:rainbow::ReadScopedLockImpl	access:public	signature:()
unlock	rainbow/thread.h	/^    void unlock() {$/;"	f	struct:rainbow::ScopedLockImpl	access:public	signature:()
unlock	rainbow/thread.h	/^    void unlock() {$/;"	f	struct:rainbow::WriteScopedLockImpl	access:public	signature:()
unlock	rainbow/thread.h	/^    void unlock() {}$/;"	f	class:rainbow::NullMutex	access:public	signature:()
unlock	rainbow/thread.h	/^    void unlock() {}$/;"	f	class:rainbow::NullRWMutex	access:public	signature:()
wait	rainbow/thread.cpp	/^void Semaphore::wait() {$/;"	f	class:rainbow::Semaphore	signature:()
wait	rainbow/thread.h	/^    void wait();$/;"	p	class:rainbow::Semaphore	access:public	signature:()
warn	rainbow/log.cpp	/^void Logger::warn(LogEvent::ptr event) { log(LogLevel::WARN, event); }$/;"	f	class:rainbow::Logger	signature:(LogEvent::ptr event)
warn	rainbow/log.h	/^    void warn(LogEvent::ptr event);$/;"	p	class:rainbow::Logger	access:public	signature:(LogEvent::ptr event)
write	rainbow/iomanager.h	/^        EventContext write;     \/\/ åäºä»¶$/;"	m	struct:rainbow::IOManager::FdContext	access:public
wrlock	rainbow/thread.h	/^    void wrlock() {$/;"	f	class:rainbow::RWMutex	access:public	signature:()
wrlock	rainbow/thread.h	/^    void wrlock() {}$/;"	f	class:rainbow::NullRWMutex	access:public	signature:()
~CASLock	rainbow/thread.h	/^    ~CASLock() {$/;"	f	class:rainbow::CASLock	access:public	signature:()
~ConfigVarBase	rainbow/config.h	/^    virtual ~ConfigVarBase() {}$/;"	f	class:rainbow::ConfigVarBase	access:public	signature:()
~Fiber	rainbow/fiber.cpp	/^Fiber::~Fiber() {$/;"	f	class:rainbow::Fiber	signature:()
~Fiber	rainbow/fiber.h	/^    ~Fiber();$/;"	p	class:rainbow::Fiber	access:public	signature:()
~FormatItem	rainbow/log.h	/^        virtual ~FormatItem() {}$/;"	f	class:rainbow::LogFormatter::FormatItem	access:public	signature:()
~IOManager	rainbow/iomanager.cpp	/^IOManager::~IOManager() {$/;"	f	class:rainbow::IOManager	signature:()
~IOManager	rainbow/iomanager.h	/^    ~IOManager();$/;"	p	class:rainbow::IOManager	access:public	signature:()
~LogAppender	rainbow/log.h	/^    virtual ~LogAppender() {}$/;"	f	class:rainbow::LogAppender	access:public	signature:()
~LogEvent	rainbow/log.h	/^    ~LogEvent() {}$/;"	f	class:rainbow::LogEvent	access:public	signature:()
~LogEventWrap	rainbow/log.cpp	/^LogEventWrap::~LogEventWrap() {$/;"	f	class:rainbow::LogEventWrap	signature:()
~LogEventWrap	rainbow/log.h	/^    ~LogEventWrap();$/;"	p	class:rainbow::LogEventWrap	access:public	signature:()
~Mutex	rainbow/thread.h	/^    ~Mutex() {$/;"	f	class:rainbow::Mutex	access:public	signature:()
~NullRWMutex	rainbow/thread.h	/^    ~NullRWMutex() {}$/;"	f	class:rainbow::NullRWMutex	access:public	signature:()
~RWMutex	rainbow/thread.h	/^    ~RWMutex() {$/;"	f	class:rainbow::RWMutex	access:public	signature:()
~ReadScopedLockImpl	rainbow/thread.h	/^    ~ReadScopedLockImpl() {$/;"	f	struct:rainbow::ReadScopedLockImpl	access:public	signature:()
~Scheduler	rainbow/scheduler.cpp	/^Scheduler::~Scheduler() {$/;"	f	class:rainbow::Scheduler	signature:()
~Scheduler	rainbow/scheduler.h	/^    virtual ~Scheduler();$/;"	p	class:rainbow::Scheduler	access:public	signature:()
~ScopedLockImpl	rainbow/thread.h	/^    ~ScopedLockImpl() {$/;"	f	struct:rainbow::ScopedLockImpl	access:public	signature:()
~Semaphore	rainbow/thread.cpp	/^Semaphore::~Semaphore() {$/;"	f	class:rainbow::Semaphore	signature:()
~Semaphore	rainbow/thread.h	/^    ~Semaphore();$/;"	p	class:rainbow::Semaphore	access:public	signature:()
~Spinlock	rainbow/thread.h	/^    ~Spinlock() {$/;"	f	class:rainbow::Spinlock	access:public	signature:()
~Thread	rainbow/thread.cpp	/^Thread::~Thread() {$/;"	f	class:rainbow::Thread	signature:()
~Thread	rainbow/thread.h	/^    ~Thread();$/;"	p	class:rainbow::Thread	access:public	signature:()
~TimerManager	rainbow/timer.cpp	/^TimerManager::~TimerManager() {$/;"	f	class:rainbow::TimerManager	signature:()
~TimerManager	rainbow/timer.h	/^    virtual ~TimerManager();$/;"	p	class:rainbow::TimerManager	access:public	signature:()
~WriteScopedLockImpl	rainbow/thread.h	/^    ~WriteScopedLockImpl() {$/;"	f	struct:rainbow::WriteScopedLockImpl	access:public	signature:()
